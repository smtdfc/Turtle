{"version":3,"file":"development.turtle.min.js","sources":["../../src/dev/events.js","../../src/dev/emitter.js","../../src/component/base.js","../../src/render/data.js","../../src/component/ref.js","../../src/render/process.js","../../src/render/directives.js","../../src/render/render.js","../../src/render/parser.js","../../src/component/state.js","../../src/context/context.js","../../src/component/component.js","../../src/modules/router/components.js","../../src/modules/router/index.js","../../src/modules/form/index.js","../../src/features/loader.js","../../src/features/performance.js","../../src/index.js","../../src/development.js","../../src/dev/dev.js","../../src/dev/listeners.js","../../src/app/app.js","../../src/service/service.js"],"sourcesContent":["/**\n * @constant {string} APP_INIT - Event triggered when the application is initialized.\n */\nexport const APP_INIT = \"APP_INIT\";\n\n/**\n * @constant {string} APP_ATTACHED - Event triggered when the application is attached to the DOM.\n */\nexport const APP_ATTACHED = \"APP_ATTACHED\";\n\n/**\n * @constant {string} APP_DESTROYED - Event triggered when the application is destroyed.\n */\nexport const APP_DESTROYED = \"APP_DESTROYED\";\n\n/**\n * @constant {string} COMPONENT_INIT - Event triggered when a component is initialized.\n */\nexport const COMPONENT_INIT = \"COMPONENT_INIT\";\n\n/**\n * @constant {string} COMPONENT_ATTACHED - Event triggered when a component is attached to the DOM.\n */\nexport const COMPONENT_ATTACHED = \"COMPONENT_ATTACHED\";\n\n/**\n * @constant {string} COMPONENT_DESTROYED - Event triggered when a component is destroyed.\n */\nexport const COMPONENT_DESTROYED = \"COMPONENT_DESTROYED\";\n\n/**\n * @constant {string} COMPONENT_UPDATED - Event triggered when a component is updated.\n */\nexport const COMPONENT_UPDATED = \"COMPONENT_UPDATED\";\n\n/**\n * @constant {string} COMPONENT_RENDERED - Event triggered when a component is rendered.\n */\nexport const COMPONENT_RENDERED = \"COMPONENT_RENDERED\";","/**\n * Emits a development event for the Turtle framework.\n *\n * This function creates and dispatches a custom event named \"turtledev\" \n * if the development mode is activated. The event includes the specified \n * event name and associated data as its detail.\n *\n * @param {string} name - The name of the event to emit.\n * @param {*} data - The data associated with the event.\n */\nexport function emitDevEvent(name, data) {\n  if (!window.__TURTLE__.dev) return;\n\n  window.dispatchEvent(new CustomEvent(\"turtledev\", {\n    detail: {\n      name,\n      data\n    }\n  }));\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\n/**\n * Custom element that represents a Turtle component in the DOM.\n * Extends HTMLElement to manage lifecycle and interaction with the Turtle component.\n */\nexport class TurtleComponentElement extends HTMLElement {\n  /**\n   * Creates an instance of TurtleComponentElement.\n   */\n  constructor() {\n    super();\n    this.app = null; // The Turtle application instance.\n    this.component = null; // The Turtle component instance.\n  }\n\n  /**\n   * Attaches a Turtle application and component to this custom element.\n   * @param {Object} app - The Turtle application instance.\n   * @param {Object} parent - The parent component or context of this component.\n   * @param {TurtleComponent} component - The Turtle component instance.\n   */\n  attach(app, parent, component) {\n    this.app = app;\n    this.component = component;\n    this.component.parent = parent;\n    this.component.contexts.parent = parent;\n    this.component.element = this;\n    this.component.app = app;\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_ATTACHED, component);\n  }\n\n  /**\n   * Lifecycle method called when the element is inserted into the DOM.\n   * Initializes and starts the attached component.\n   */\n  connectedCallback() {\n    this.component.onInit();\n    this.component.start();\n    this.component.onCreate();\n    this.component.startRender();\n  }\n\n  /**\n   * Lifecycle method called when the element is removed from the DOM.\n   * Can be used for cleanup operations if needed.\n   */\n  disconnectedCallback() {\n    this.component.onDestroy();\n    // Add any cleanup code here if necessary\n  }\n}\n\n// Define the custom element \"turtle-component\" with the TurtleComponentElement class.\nwindow.customElements.define(\"turtle-component\", TurtleComponentElement);","/**\n * Represents the rendering Data for Turtle components.\n * This class manages references, bindings, and events for rendering.\n */\nexport class TurtleRenderData {\n  /**\n   * Creates an instance of TurtleRenderData.\n   * \n   * @param {DocumentFragment} [root] - The root element for rendering. Defaults to a new DocumentFragment.\n   */\n  constructor(root) {\n    this.root = root ?? document.createDocumentFragment();\n    this.refs = {};\n    this.bindings = {};\n    this.events = {};\n  }\n\n  /**\n   * Adds a binding for a specific state.\n   * \n   * @param {string} state - The name of the state to bind.\n   * @param {Object} configs - Configuration object for the binding, which may include callback functions or parameters.\n   */\n  addBinding(state, configs) {\n    if (!this.bindings[state]) {\n      this.bindings[state] = [];\n    }\n    this.bindings[state].push(configs);\n  }\n\n  /**\n   * Adds a reference to a DOM element with a unique name.\n   * \n   * @param {string} name - The unique name for the reference.\n   * @param {HTMLElement} element - The DOM element to be referenced.\n   * @throws {Error} Throws an error if a reference with the same name already exists.\n   * @private\n   */\n  addRef(name, element) {\n    if (this.refs[name]) {\n      throw new Error(`[Turtle Render Error] Multiple elements are assigned the same ref, which is not allowed. Each ref must be unique to a single DOM element.`);\n    }\n\n    this.refs[name] = element;\n  }\n\n  /**\n   * Retrieves a referenced DOM element by its unique name.\n   * \n   * @param {string} name - The unique name for the reference.\n   * @returns {HTMLElement} - The referenced DOM element.\n   * @throws {Error} Throws an error if no reference with the given name exists.\n   */\n  getRef(name) {\n    const ref = this.refs[name];\n    if (!ref) {\n      throw new Error(`[Turtle Render Error] No ref found with the name: ${name}`);\n    }\n    return ref;\n  }\n\n  /**\n   * Removes a reference by its unique name.\n   * \n   * @param {string} name - The unique name for the reference to remove.\n   * @throws {Error} Throws an error if no reference with the given name exists.\n   */\n  removeRef(name) {\n    if (!this.refs[name]) {\n      throw new Error(`[Turtle Render Error] Cannot remove ref: No ref found with the name: ${name}`);\n    }\n    delete this.refs[name];\n  }\n}","/**\n * Represents a reference to the element associated with a Turtle component.\n */\nexport class TurtleComponentRef {\n  #element;\n\n  /**\n   * Creates an instance of TurtleComponentRef.\n   * @param {HTMLElement} element - The HTML element associated with the Turtle component.\n   */\n  constructor(element) {\n    if (!element) {\n      throw new Error('[Turtle Component Ref Error] An element must be provided.');\n    }\n    this.#element = element;\n  }\n\n  /**\n   * Gets the forward references of the component associated with the element.\n   * @returns {Object} The forward references of the component.\n   * @throws {Error} If the element does not have an associated component.\n   */\n  get component() {\n    if (!this.#element.component) {\n      throw new Error('[Turtle Component Ref Error] The element does not have an associated component.');\n    }\n    return this.#element.component.forwardRefs;\n  }\n\n  // You can add more methods here to interact with the component or element.\n}","import { EventDirective, BindingDirective, HTMLDirective, TextContentDirective, RefDirective } from './directives.js';\nimport { TurtleComponentRef } from '../component/ref.js';\n\n/**\n * Extracts the name from the directive based on the given prefix.\n *\n * @param {string} name - The name of the directive.\n * @param {string} start - The prefix to extract from the name.\n * @returns {string|null} The extracted name without the prefix, or null if the prefix is not found.\n */\nfunction extractName(name, start) {\n  if (name.startsWith(start)) return name.substring(start.length);\n  return null;\n}\n\n/**\n * Applies a directive based on its name and value to a target element.\n *\n * @param {HTMLElement} target - The target element to which the directive is applied.\n * @param {string} name - The name of the directive.\n * @param {string} value - The value associated with the directive.\n * @param {Object} context - The context in which the directive is applied.\n * @returns {boolean} Returns true if the directive was successfully applied, otherwise false.\n */\nfunction applyDirective(target, name, value, context) {\n  let passed = false;\n  for (let prefix in directives) {\n    const ename = extractName(name, prefix);\n    const DirectiveClass = directives[ename != null ? prefix : name];\n    if (!DirectiveClass) {\n      continue;\n    }\n    const directiveInstance = new DirectiveClass(target, ename, value, context);\n    if (typeof directiveInstance.apply === 'function') {\n      directiveInstance.apply();\n      passed = true;\n    }\n    break;\n  }\n  return passed;\n}\n\n// Map of directive prefixes to their corresponding classes\nconst directives = {\n  \"tevent-\": EventDirective,\n  \"tbind-\": BindingDirective,\n  \"thtml\": HTMLDirective,\n  \"ttext\": TextContentDirective,\n  \"ref\": RefDirective\n};\n\n/**\n * Processes attributes of a given node and applies directives accordingly.\n *\n * @param {HTMLElement} target - The target element to process attributes for.\n * @param {Element} node - The node from which to extract attributes.\n * @param {Object} context - The context in which the attributes are processed.\n * @param {Object} data - Additional data to be used during processing.\n */\nexport function processAttribute(target, node, context, data) {\n  for (let attribute of Array.from(node.attributes)) {\n    let name = attribute.name;\n    let value = attribute.value;\n    let isDirective = applyDirective(target, name, value, context);\n    if (!isDirective) {\n      target.setAttribute(name, value);\n    }\n  }\n}\n\n/**\n * Processes a DOM tree, creating elements and applying directives as needed.\n *\n * @param {HTMLElement} element - The parent element to which new elements are appended.\n * @param {Node} tree - The DOM tree to process.\n * @param {Object} context - The context for processing.\n * @param {Object} data - Additional data, including component mappings.\n * @param {Object} app - The application context for components.\n */\nexport function process(element, tree, context, data, app) {\n  for (let node of Array.from(tree.childNodes)) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      element.appendChild(node);\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      if (data.components[node.nodeName]) {\n        let component = data.components[node.nodeName];\n        let componentElement = document.createElement(\"turtle-component\");\n        componentElement.attach(app, context.root, component);\n        if (node.getAttribute(\"ref\")) {\n          context.addRef(\n            node.getAttribute(\"ref\"),\n            new TurtleComponentRef(componentElement)\n          );\n        }\n        element.appendChild(componentElement);\n      } else {\n        let newElement = document.createElement(node.tagName);\n        processAttribute(newElement, node, context, data);\n        if (node.childNodes.length > 0) process(newElement, node, context, data);\n        element.appendChild(newElement);\n      }\n    }\n  }\n}","/**\n * Represents an event directive for adding event listeners to a target element.\n */\nexport class EventDirective {\n  /**\n   * Creates an instance of EventDirective.\n   * \n   * @param {HTMLElement} target - The target element to attach the event listener to.\n   * @param {string} name - The name of the event to listen for.\n   * @param {string} value - The name of the method to call on the event.\n   * @param {Object} context - The context in which the event method is defined.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the event directive by adding the event listener to the target element.\n   */\n  apply() {\n    if (this.context.root[this.value]) {\n      this.target.addEventListener(this.name, this.context.root[this.value].bind(this.context.root));\n    }\n  }\n}\n\n/**\n * Represents a binding directive for binding attributes to a target element.\n */\nexport class BindingDirective {\n  /**\n   * Creates an instance of BindingDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind the attribute to.\n   * @param {string} name - The name of the attribute to bind.\n   * @param {string} value - The state name to bind to the attribute.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the binding directive by adding a binding for the attribute to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"attribute\",\n      name: this.name,\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents an HTML directive for binding innerHTML to a target element.\n */\nexport class HTMLDirective {\n  /**\n   * Creates an instance of HTMLDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind innerHTML to.\n   * @param {string} name - The name of the property (always 'innerHTML').\n   * @param {string} value - The state name to bind to innerHTML.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the HTML directive by adding a binding for innerHTML to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"property\",\n      name: \"innerHTML\",\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents a text content directive for binding textContent to a target element.\n */\nexport class TextContentDirective {\n  /**\n   * Creates an instance of TextContentDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind textContent to.\n   * @param {string} name - The name of the property (always 'textContent').\n   * @param {string} value - The state name to bind to textContent.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the text content directive by adding a binding for textContent to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"property\",\n      name: \"textContent\",\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents a reference directive for adding a reference to a DOM element.\n */\nexport class RefDirective {\n  /**\n   * Creates an instance of RefDirective.\n   * \n   * @param {HTMLElement} target - The target element to be referenced.\n   * @param {string} name - The name of the reference.\n   * @param {string} value - The unique name to assign to the reference.\n   * @param {Object} context - The context for managing references.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the reference directive by adding a reference to the target element.\n   */\n  apply() {\n    this.context.addRef(this.value, this.target);\n  }\n}","import { TurtleRenderData } from './data.js';\nimport { TurtleComponent } from '../component/component.js';\nimport { parseHTML } from './parser.js';\nimport { process } from './process.js';\n\n/**\n * Renders a template by processing its raw HTML and inserting values into it.\n *\n * @param {HTMLElement} element - The parent element to which the rendered content will be appended.\n * @param {TemplateStringsArray} template - The template containing the raw HTML and associated values.\n * @param {TurtleRenderData} [context=new TurtleRenderData()] - The context for rendering, defaulting to a new instance.\n * @param {Object|null} [app=null] - The application context, optional parameter.\n * @returns {HTMLElement} The parent element after rendering the template.\n */\nexport function render(element, template, context = new TurtleRenderData(), app = null) {\n  let raw = template.raw; // Raw HTML string from the template\n  let values = template.values; // Values to be inserted into the raw HTML\n  let data = {\n    components: {} // Object to hold components being rendered\n  };\n\n  for (let i = 0; i < values.length; i++) {\n    let key = `turtle-component-${(Math.floor(Math.random() * 999999) * Date.now()).toString(16)}`;\n    if (values[i]) {\n      if (values[i] instanceof TurtleComponent) {\n        data.components[key] = values[i]; // Store the component\n        values[i] = key; // Replace component with its key in values\n      } else if (values[i].instance === TurtleComponent) {\n        data.components[key] = values[i]({}); // Call the instance function if it's a component\n        values[i] = key; // Replace instance with its key\n      }\n    }\n  }\n\n  let content = String.raw(raw, ...values);\n  let tree = parseHTML(content);\n\n  process(element, tree, context, data, app);\n\n  return element;\n}\n\nexport class TurtleRenderHelper{\n  constructor(app,root,context=new TurtleRenderData()){\n    this.app = app\n    this.context = context \n    this.root = root\n  }\n  \n  fragment(raw,...values){\n    return render(document.createDocumentFragment(), { raw, values }, this.context, this.app)\n  }\n  \n  render(raws,...values){\n    this.root.textContent = \"\"\n    this.root.appendChild(render(document.createDocumentFragment(), { raw, values }, this.context, this.app))\n  }\n}","/**\n * Parses a string of HTML content and wraps it in a root element.\n * \n * @param {string} content - The HTML content to parse.\n * @returns {Element|null} - Returns the root element if parsing is successful, or null if there is a parsing error.\n * @throws {Error} Throws an error if there is a parsing issue with detailed information.\n */\nexport function parseHTML(content) {\n  let parser = new DOMParser();\n  let doc = parser.parseFromString(`<root>${content}</root>`, \"text/xml\");\n  let parserError = doc.getElementsByTagName(\"parsererror\");\n\n  if (parserError.length > 0) {\n    const errorMessage = \"Rendering error: \" + parserError[0].textContent;\n    console.log(errorMessage);\n    throw new Error(errorMessage);\n  } else {\n    return doc.getElementsByTagName(\"root\")[0];\n  }\n}","/**\n * Represents a state for a Turtle component.\n * It holds the state name, value, and manages updates when the state changes.\n */\nexport class TurtleComponentState {\n\n  /**\n   * Creates an instance of TurtleComponentState.\n   * \n   * @param {string} name - The name of the state.\n   * @param {*} value - The initial value of the state.\n   * @param {Object} component - The component that the state is associated with.\n   */\n  constructor(name, value, component) {\n    this.name = name;\n    this.value = value;\n    this.component = component;\n    this.reactive = true;\n  }\n\n  /**\n   * Retrieves the current value of the state.\n   * \n   * @returns {*} The current value of the state.\n   */\n  get() {\n    return this.value;\n  }\n\n  /**\n   * Sets a new value for the state and triggers a component update if it's reactive.\n   * \n   * @param {*} value - The new value to set for the state.\n   * @returns {*} The updated value.\n   */\n  set(value) {\n    this.value = value;\n    // Trigger the watcher if one is defined for this state.\n    if (this.component.watchers[this.name]) {\n      this.component.watchers[this.name](value);\n    }\n    // Trigger a component update if the component and state are reactive.\n    if (this.component.reactive && this.reactive) {\n      this.component.requestUpdate({\n        state: this.name,\n        value: value\n      });\n    }\n\n    return value;\n  }\n\n  /**\n   * Synchronizes the state with a given context and key, establishing a binding.\n   * \n   * @param {Object} context - The context to bind the state to.\n   * @param {string} key - The key under which the state will be bound in the context.\n   * @returns {TurtleComponentState} The instance of the state for chaining.\n   */\n  sync(context, key) {\n    context.sync(key, this);\n    return this;\n  }\n}","/**\n * Represents a context for managing bindings and values in the Turtle framework.\n */\nexport class TurtleContext {\n  constructor() {\n    this._bindings = {};\n    this._values = {};\n    this._events = {};\n    this._isLocal = false;\n  }\n\n  /**\n   * Updates all reactive bindings for a given name with a new value.\n   * \n   * @param {string} name - The name of the binding to update.\n   * @param {*} value - The new value to set for the binding.\n   * @private\n   */\n  _reactive(name, value) {\n    if (!this._bindings[name]) this._bindings[name] = [];\n    for (const bond of this._bindings[name]) {\n      bond.set(value);\n    }\n  }\n\n  /**\n   * Sets a value for a given name and triggers reactive updates.\n   * \n   * @param {string} name - The name of the value to set.\n   * @param {*} value - The value to set.\n   */\n  set(name, value) {\n    this._values[name] = value;\n    this._reactive(name, value);\n  }\n\n  /**\n   * Retrieves the value for a given name.\n   * \n   * @param {string} name - The name of the value to retrieve.\n   * @returns {*} The value associated with the name.\n   */\n  get(name) {\n    return this._values[name];\n  }\n\n  /**\n   * Synchronizes a state with a given name, establishing a binding.\n   * \n   * @param {string} name - The name to bind the state to.\n   * @param {Object} state - The state object to bind.\n   */\n  sync(name, state) {\n    if (!this._bindings[name]) this._bindings[name] = [];\n    this._bindings[name].push(state);\n  }\n\n  /**\n   * Registers an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to execute when the event occurs.\n   */\n  on(name, callback) {\n    if (!this._events[name]) {\n      this._events[name] = [];\n    }\n    this._events[name].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(name, callback) {\n    if (this._events[name]) {\n      this._events[name] = this.events[name].filter(cb => cb !== callback);\n    }\n  }\n\n  /**\n   * Triggers an event with the specified name and data.\n   * @param {string} name - The name of the event to trigger.\n   * @param {*} data - The data to pass to the event callbacks.\n   */\n  emit(name, data) {\n    if (this._events[name]) {\n      this._events[name].forEach(callback => callback(data));\n    }\n  }\n}\n\n/**\n * Manages context retrieval and usage in the Turtle framework.\n */\nexport class TurtleContextManagement {\n  constructor(parent, target) {\n    this.parent = parent;\n    this.target = target;\n  }\n\n  /**\n   * Retrieves a context by its name, optionally allowing child access.\n   * \n   * @param {string} name - The name of the context to retrieve.\n   * @param {boolean} isChildAccess - Whether to allow access to child contexts.\n   * @returns {TurtleContext|null} The requested context or null if not found.\n   */\n  get(name, isChildAccess = false) {\n    if (this.target._contexts[name] && (isChildAccess && this.target._contexts[name]._isLocal)) {\n      return null;\n    }\n\n    if (this.target._contexts[name]) {\n      return this.target._contexts[name];\n    } else if (this.parent) {\n      return this.parent.contexts.get(name, true);\n    }\n  }\n\n  /**\n   * Uses a context with a given name and associates it with the target.\n   * \n   * @param {string} name - The name of the context to use.\n   * @param {TurtleContext} context - The context to use.\n   * @param {boolean} isLocal - Indicates whether the context is local.\n   */\n  use(name, context, isLocal = false) {\n    if (this.target._contexts[name] || (this.parent && this.parent.contexts.get(name))) {\n      console.warn(`[Turtle Data Warning] Context key \"${name}\" already exists. The existing context will be overwritten.`);\n    }\n    this.target._contexts[name] = context;\n    this.target._contexts[name]._isLocal = isLocal;\n  }\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\nimport { render } from '../render/render.js';\nimport { TurtleRenderData } from '../render/data.js';\nimport { TurtleComponentState } from './state.js';\nimport { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n/**\n * Represents a Turtle Component.\n */\nexport class TurtleComponent {\n  /**\n   * Creates an instance of TurtleComponent.\n   * @param {Object} props - The properties passed to the component.\n   */\n  constructor(props) {\n    this.parent = null;\n    this.app = null;\n    this.element = null;\n    this.props = props;\n    this.watchers = {};\n    this.forwardRefs = {};\n    this.states = {};\n    this.reactive = true;\n    this._contexts = {};\n    this.contexts = new TurtleContextManagement(this.parent, this);\n    this.renderContext = new TurtleRenderData(this);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_INIT, this);\n  }\n\n  /**\n   * Registers a context for use within the component.\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - The context instance.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context,isLocal=false) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.use(name, context,isLocal);\n    return context\n  }\n\n  /**\n   * Retrieves a context by name.\n   * @param {string} name - The name of the context.\n   * @returns {TurtleContext} The requested context instance.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Gets the references from the render context.\n   * @returns {Object} The refs object.\n   */\n  get refs() {\n    return this.renderContext.refs;\n  }\n\n  /**\n   * Creates a new state for the component.\n   * @param {string} name - The name of the state.\n   * @param {*} value - The initial value of the state.\n   * @returns {TurtleComponentState} The created state object.\n   */\n  createState(name, value) {\n    let state = new TurtleComponentState(name, value, this);\n    this.states[name] = state;\n    return state;\n  }\n\n  /**\n   * Sets the state of the component.\n   * @param {string} name - The name of the state.\n   * @param {*} value - The new value of the state.\n   */\n  setState(name, value) {\n    if (!this.states[name]) {\n      this.states[name] = new TurtleComponentState(name, value, this);\n    }\n    this.states[name].set(value);\n  }\n\n  /**\n   * Gets the value of a specific state.\n   * @param {string} name - The name of the state.\n   * @returns {*} The value of the state.\n   */\n  getState(name) {\n    return this.states[name].get();\n  }\n\n  /**\n   * Gets the state object by its name.\n   * @param {string} name - The name of the state.\n   * @returns {TurtleComponentState} The state object.\n   */\n  state(name) {\n    return this.states[name];\n  }\n\n  /**\n   * Creates a fragment using a template literal and values.\n   * @param {TemplateStringsArray} raw - The raw template literal.\n   * @param {...*} values - The values to be used in the template.\n   * @returns {DocumentFragment} The rendered HTML as a DocumentFragment.\n   */\n  html(raw, ...values) {\n    let fragment = render(document.createDocumentFragment(), { raw, values }, this.renderContext, this.app);\n    return fragment;\n  }\n\n  /**\n   * Sets up the initial states for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing initial state values.\n   */\n  setupState() {\n    return {};\n  }\n\n  /**\n   * Sets up watchers for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing watcher functions.\n   */\n  setupWatcher() {\n    return {};\n  }\n\n  /**\n   * Sets up forward references for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing forward references.\n   */\n  setupForwardRef() {\n    return {};\n  }\n\n  /**\n   * Lifecycle method called when the component is initialized.\n   * Should be overridden by subclasses.\n   */\n  onInit() {}\n\n  /**\n   * Lifecycle method called when the component is created.\n   * Should be overridden by subclasses.\n   */\n  onCreate() {}\n\n  /**\n   * Lifecycle method called when the component is destroyed.\n   * Should be overridden by subclasses.\n   */\n  onDestroy() {}\n\n  /**\n   * Lifecycle method called after the component is rendered.\n   * Should be overridden by subclasses.\n   */\n  onRender() {}\n\n  /**\n   * Lifecycle method called when the component is updated.\n   * Should be overridden by subclasses.\n   * @param {Object} commit - The commit object representing state changes.\n   */\n  onUpdate(commit) {}\n\n  /**\n   * Returns the template of the component.\n   * Should be overridden by subclasses.\n   * @returns {DocumentFragment} The template as a DocumentFragment.\n   */\n  template() {}\n\n  /**\n   * Requests an update for the component and triggers the onUpdate lifecycle method.\n   * @param {Object} commit - The commit object representing state changes.\n   * @returns {Promise<void>}\n   */\n  async requestUpdate(commit) {\n    this._reactive(commit);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_UPDATED, this);\n    this.onUpdate(commit);\n  }\n\n  /**\n   * Requests a render for the component using its template.\n   * @returns {Promise<void>}\n   */\n  async requestRender() {\n    let fragment = this.template();\n    this.element.textContent = \"\";\n    this.element.appendChild(fragment);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_RENDERED, this);\n    this.onRender();\n  }\n\n  /**\n   * Handles reactivity for state changes.\n   * @param {Object} commit - The commit object representing state changes.\n   */\n  _reactive(commit) {\n    let bindings = this.renderContext.bindings[commit.state];\n    if (!bindings) return;\n    for (let bind of bindings) {\n      if (bind.type === \"property\") bind.target[bind.name] = commit.value;\n      if (bind.type === \"attribute\") bind.target.setAttribute(bind.name, commit.value);\n    }\n  }\n\n  /**\n   * Initializes the states for the component.\n   * @param {Object} states - An object containing state names and initial values.\n   */\n  initStates(states) {\n    for (let stateName in states) {\n      this.states[stateName] = new TurtleComponentState(stateName, states[stateName], this);\n    }\n  }\n\n  /**\n   * Starts the component by setting up forward references, watchers, and states, then requests a render.\n   */\n  start() {\n    this.forwardRefs = this.setupForwardRef() ?? {};\n    this.watchers = this.setupWatcher() ?? {};\n    this.initStates(this.setupState() ?? {});\n    \n  }\n  \n  startRender(){\n    this.requestRender();\n  }\n}\n\n/**\n * Creates a new TurtleComponent instance.\n * @param {Function} constructor - The constructor function for the TurtleComponent.\n * @returns {Function} A function that creates an instance of the specified component.\n */\nexport function createComponent(constructor) {\n  /**\n   * Initializes the component with the given properties.\n   * @param {Object} props - The properties to be passed to the component.\n   * @returns {TurtleComponent} The instantiated component.\n   */\n  function fn(...props) {\n    let component = new constructor(props);\n    component.props = props;\n    return component;\n  }\n\n  fn.instance = TurtleComponent;\n  return fn;\n}","import { TurtleComponent, createComponent } from '../../component/component.js';\n\nexport class TurtleRouteComponent extends TurtleComponent {\n  constructor(props) {\n    super(props)\n    this.matched = false\n  }\n\n  onInit() {\n    const [routes] = this.props;\n\n    if (Array.isArray(routes)) {\n      this.routes = {};\n      routes.forEach(({ component, path }) => {\n        if (Array.isArray(path)) {\n          path.forEach(p => this.routes[p] = component);\n        } else {\n          this.routes[path] = component;\n        }\n      });\n    } else if (typeof routes === \"object\") {\n      this.routes = routes;\n    }\n\n  }\n\n  active() {\n    if (this.app.router) {\n      let router = this.app.router\n      let [status, matched] = router.match(Object.keys(this.routes), router.currentPath())\n      if ((status) && !this.matched) {\n        this.matched = true\n        this.element.appendChild(this.html`\n          <${this.routes[matched]}/>\n        `)\n      }\n      if (!status) {\n        this.matched = false\n        this.element.textContent = \"\"\n      }\n    }\n  }\n\n  onRender() {\n    this.active()\n    if (this.app.router) {\n      this.app.router.on(\"pagechange\", this.active.bind(this))\n    }\n  }\n\n  template() {\n    return this.html``\n  }\n}\n\n\nexport const TurtleRoute = createComponent(TurtleRouteComponent)","import { render } from '../../render/render.js';\nimport { TurtleRenderData } from '../../render/data.js';\n\n/**\n * TurtleRouterModule manages routing in a Turtle application.\n * It handles matching routes, invoking callbacks, and rendering components based on URLs.\n */\nexport class TurtleRouterModule {\n\n  /**\n   * Creates a new TurtleRouterModule instance.\n   *\n   * @param {Object} app - The Turtle app instance this router is attached to.\n   * @param {Object} configs - Configuration for the router, including the root element.\n   */\n  constructor(app, configs) {\n    this.root = configs.element ?? document.createElement(\"div\");\n    this._app = app;\n    this._app.modules.push(this);\n    this._app.router = this;\n    this.routes = {};\n    this.matched = null;\n    this.url = null;\n    this.params = {};\n    this.query = new URLSearchParams();\n    this.events = {\n      notallow: [],\n      notfound: [],\n      pagematches: [],\n      pageloaded: [],\n      pagechange: []\n    };\n  }\n\n  /**\n   * Registers an event listener for a specific router event.\n   *\n   * @param {string} event - The name of the event (e.g., 'pagechange', 'notfound').\n   * @param {function} callback - The function to call when the event is triggered.\n   */\n  on(event, callback) {\n    this.events[event].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specific router event.\n   *\n   * @param {string} event - The name of the event.\n   * @param {function} callback - The callback function to remove.\n   */\n  off(event, callback) {\n    this.events[event].forEach((fn, idx) => {\n      if (fn === callback) {\n        this.events[event].splice(idx, 1);\n      }\n    });\n  }\n\n  /**\n   * Initializes the TurtleRouterModule.\n   *\n   * @param {Object} app - The Turtle app instance.\n   * @param {Object} configs - Configuration for the router.\n   * @returns {TurtleRouterModule} - The initialized router module.\n   */\n  static init(app, configs) {\n    return new TurtleRouterModule(app, configs);\n  }\n\n  match(patterns, url) {\n    let u = new URL(url, window.location.origin);\n    url = u.pathname;\n\n    if (!patterns) return\n    for (let i = 0; i < patterns.length; i++) {\n      let route = patterns[i]\n      let routeSplited = route.split(\"/\");\n      let urlSplited = url.split(\"/\");\n      let passed = true;\n      let params = {};\n\n      if (urlSplited.length != routeSplited.length) {\n        passed = false;\n      } else {\n        for (let i = 0; i < routeSplited.length; i++) {\n          if (urlSplited[i] === undefined) {\n            passed = false;\n          }\n\n          if (routeSplited[i] == \"*\") {\n            break;\n          }\n\n          if (routeSplited[i][0] == \":\") {\n            let name = routeSplited[i].substring(1, routeSplited[i].length);\n            params[name] = urlSplited[i];\n            continue;\n          }\n\n          if (routeSplited[i] != urlSplited[i]) {\n            passed = false;\n          }\n        }\n      }\n      if (passed) return [true,route]\n    }\n    return [false,null]\n  }\n\n  /**\n   * Matches the provided URL against the router's routes.\n   *\n   * @param {string} url - The URL to match against the defined routes.\n   * @returns {Promise<void>} - A promise that resolves when the match is complete.\n   */\n  async matches(url) {\n    let u = new URL(url, window.location.origin);\n    url = u.pathname;\n    this.emitEvent(\"pagechange\", this);\n    for (let j = 0; j < Object.keys(this.routes).length; j++) {\n      let route = Object.keys(this.routes)[j];\n      let configs = this.routes[route];\n      let routeSplited = route.split(\"/\");\n      let urlSplited = url.split(\"/\");\n      let passed = true;\n      let params = {};\n\n      if (urlSplited.length != routeSplited.length) {\n        passed = false;\n      } else {\n        for (let i = 0; i < routeSplited.length; i++) {\n          if (urlSplited[i] === undefined) {\n            passed = false;\n          }\n\n          if (routeSplited[i] == \"*\") {\n            break;\n          }\n\n          if (routeSplited[i][0] == \":\") {\n            let name = routeSplited[i].substring(1, routeSplited[i].length);\n            params[name] = urlSplited[i];\n            continue;\n          }\n\n          if (routeSplited[i] != urlSplited[i]) {\n            passed = false;\n          }\n        }\n      }\n\n      if (passed) {\n        this.params = params;\n        this.query = u.searchParams;\n        this.matched = route;\n        this.url = url;\n        let component = new Function();\n        if (configs.callback) { await configs.callback(); }\n        if (configs.protect) {\n          let result = await configs.protect();\n          if (!result) {\n            this.triggerError(\"not_allow\");\n            return;\n          }\n        }\n        this.emitEvent(\"pagematches\", this);\n\n        if (configs.loader) {\n          component = await configs.loader();\n        }\n\n        if (configs.component) {\n          component = configs.component;\n        }\n        let ctx = this;\n        let element = this.root;\n\n        function renderContent(raw, ...values) {\n          element.textContent = \"\";\n          element.appendChild(render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(ctx._app), ctx._app));\n        }\n\n        this.emitEvent(\"pageloaded\", this);\n        return renderContent`<${component}/>`;\n      }\n    }\n\n    this.triggerError(\"not_found\");\n  }\n\n  /**\n   * Starts the router and listens for changes in the URL.\n   */\n  start() {\n    let started = false;\n    let path = window.location.hash;\n    if (path.length == 0) {\n      path = \"/\";\n      window.location = \"#\";\n    } else {\n      path = path.slice(2);\n    }\n\n    window.addEventListener(\"hashchange\", function() {\n      if (started) {\n        let path = window.location.hash;\n        if (path.length == 0) {\n          path = \"/\";\n        } else {\n          path = path.slice(2);\n        }\n\n        this.matches(path);\n      }\n    }.bind(this));\n    started = true;\n    this.matches(path);\n    started = true;\n  }\n\n  currentPath() {\n    let path = window.location.hash;\n    if (path.length == 0) {\n      path = \"/\";\n    } else {\n      path = path.slice(2);\n    }\n    return path\n  }\n\n  /**\n   * Redirects to a new route.\n   *\n   * @param {string} path - The path to navigate to.\n   * @param {boolean} [replace=false] - Whether to replace the current URL or push a new one.\n   */\n  redirect(path, replace = false) {\n    if (!replace) {\n      window.location.hash = `!${path}`;\n    } else {\n      window.history.replaceState(null, null, `./#!${path}`);\n      this.matches(path);\n    }\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param {string} name - The event name.\n   * @param {*} data - The data to pass with the event.\n   */\n  emitEvent(name, data) {\n    this.events[name].forEach(fn => {\n      fn(data);\n    });\n  }\n\n  /**\n   * Triggers a router error event.\n   *\n   * @param {string} name - The error event name (e.g., 'not_allow', 'not_found').\n   */\n  triggerError(name) {\n    switch (name) {\n      case 'not_allow':\n        this.emitEvent(\"notallow\", this);\n        break;\n\n      case 'not_found':\n        this.emitEvent(\"notfound\", this);\n        break;\n    }\n  }\n}\n\nexport * from \"./components.js\"","export class TurtleFormModuleValidatorRules {\n  /**\n   * Creates an instance of TurtleFormModuleValidatorRules.\n   */\n  constructor() {\n    this.validations = [];\n    this.errors = [];\n    this.fieldAlias = null;\n  }\n\n  /**\n   * Sets an alias for the field being validated.\n   * @param {string} name - The alias name for the field.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  alias(name) {\n    this.validations.push({\n      rule: (value) => true,\n    });\n    this.fieldAlias = name;\n    return this;\n  }\n\n  /**\n   * Validates that the value is not null or empty.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNotNull() {\n    this.validations.push({\n      rule: (value) => value !== null && value !== undefined && value.trim() !== \"\",\n      errorMessage: \"Value cannot be null or empty.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value does not exceed the specified maximum length.\n   * @param {number} max - The maximum allowed length of the value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  maxLength(max) {\n    this.validations.push({\n      rule: (value) => value.length <= max,\n      errorMessage: `Value must be at most ${max} characters long.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value meets the specified minimum length.\n   * @param {number} min - The minimum required length of the value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  minLength(min) {\n    this.validations.push({\n      rule: (value) => value.length >= min,\n      errorMessage: `Value must be at least ${min} characters long.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsNumber() {\n    this.validations.push({\n      rule: (value) => /\\d/.test(value),\n      errorMessage: \"Value must contain at least one number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one uppercase letter.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsUppercase() {\n    this.validations.push({\n      rule: (value) => /[A-Z]/.test(value),\n      errorMessage: \"Value must contain at least one uppercase letter.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one lowercase letter.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsLowercase() {\n    this.validations.push({\n      rule: (value) => /[a-z]/.test(value),\n      errorMessage: \"Value must contain at least one lowercase letter.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one special character.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsSpecialChar() {\n    this.validations.push({\n      rule: (value) => /[!@#$%^&*(),.?\":{}|<>]/.test(value),\n      errorMessage: \"Value must contain at least one special character.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid email address.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isEmail() {\n    this.validations.push({\n      rule: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n      errorMessage: \"Value must be a valid email address.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid phone number in international format.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isPhoneNumber() {\n    this.validations.push({\n      rule: (value) => /^\\+?[1-9]\\d{1,14}$/.test(value),\n      errorMessage: \"Value must be a valid phone number in international format.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid date.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isDate() {\n    this.validations.push({\n      rule: (value) => !isNaN(Date.parse(value)),\n      errorMessage: \"Value must be a valid date.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the date is before a specified date.\n   * @param {string} date - The date to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isBefore(date) {\n    this.validations.push({\n      rule: (value) => new Date(value) < new Date(date),\n      errorMessage: `Date must be before ${date}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the date is after a specified date.\n   * @param {string} date - The date to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAfter(date) {\n    this.validations.push({\n      rule: (value) => new Date(value) > new Date(date),\n      errorMessage: `Date must be after ${date}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is within a specified range.\n   * @param {number} min - The minimum allowed value.\n   * @param {number} max - The maximum allowed value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isInRange(min, max) {\n    this.validations.push({\n      rule: (value) => value >= min && value <= max,\n      errorMessage: `Value must be between ${min} and ${max}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value matches a specified regular expression.\n   * @param {RegExp} regex - The regular expression to test against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  matchesRegex(regex) {\n    this.validations.push({\n      rule: (value) => regex.test(value),\n      errorMessage: `Value must match the required pattern.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only alphabetic characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAlpha() {\n    this.validations.push({\n      rule: (value) => /^[a-zA-Z]+$/.test(value),\n      errorMessage: \"Value must contain only alphabetic characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only alphanumeric characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAlphaNumeric() {\n    this.validations.push({\n      rule: (value) => /^[a-zA-Z0-9]+$/.test(value),\n      errorMessage: \"Value must contain only alphanumeric characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only numeric characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNumeric() {\n    this.validations.push({\n      rule: (value) => /^[0-9]+$/.test(value),\n      errorMessage: \"Value must contain only numeric characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid URL.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isUrl() {\n    this.validations.push({\n      rule: (value) => /^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/.test(value),\n      errorMessage: \"Value must be a valid URL.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is equal to a specified value.\n   * @param {*} compareValue - The value to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isEqualTo(compareValue) {\n    this.validations.push({\n      rule: (value) => value === compareValue,\n      errorMessage: `Value must be equal to ${compareValue}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is not equal to a specified value.\n   * @param {*} compareValue - The value to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNotEqualTo(compareValue) {\n    this.validations.push({\n      rule: (value) => value !== compareValue,\n      errorMessage: `Value must not be equal to ${compareValue}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value starts with a specified prefix.\n   * @param {string} prefix - The prefix to check against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  startsWith(prefix) {\n    this.validations.push({\n      rule: (value) => value.startsWith(prefix),\n      errorMessage: `Value must start with '${prefix}'.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value ends with a specified suffix.\n   * @param {string} suffix - The suffix to check against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  endsWith(suffix) {\n    this.validations.push({\n      rule: (value) => value.endsWith(suffix),\n      errorMessage: `Value must end with '${suffix}'.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a positive number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isPositiveNumber() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && Number(value) > 0,\n      errorMessage: \"Value must be a positive number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a negative number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNegativeNumber() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && Number(value) < 0,\n      errorMessage: \"Value must be a negative number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is an integer.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isInteger() {\n    this.validations.push({\n      rule: (value) => Number.isInteger(Number(value)),\n      errorMessage: \"Value must be an integer.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a floating-point number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isFloat() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && value.toString().includes('.'),\n      errorMessage: \"Value must be a floating-point number.\"\n    });\n    return this;\n  }\n\n  validate(value) {\n    this.errors = [];\n    for (const validation of this.validations) {\n      if (!validation.rule(value)) {\n        this.errors.push(validation.errorMessage);\n      }\n    }\n    return this.errors.length === 0;\n  }\n\n  getErrors() {\n    return this.errors;\n  }\n\n}\n\n/**\n * Class representing a form validator module.\n */\nclass TurtleFormModuleValidator {\n  /**\n   * Creates an instance of the form validator.\n   * @param {Object} module - The module associated with the validator.\n   * @param {HTMLElement} element - The form element to validate.\n   */\n  constructor(module, element) {\n    this._module = module;\n    this.element = element;\n    this.events = {};\n    this.rules = {};\n  }\n\n  /**\n   * Registers an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to execute when the event occurs.\n   */\n  on(name, callback) {\n    if (!this.events[name]) {\n      this.events[name] = [];\n    }\n    this.events[name].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(name, callback) {\n    if (this.events[name]) {\n      this.events[name] = this.events[name].filter(cb => cb !== callback);\n    }\n  }\n\n  /**\n   * Validates the form elements based on defined rules and triggers the appropriate events.\n   */\n  validate() {\n    const values = {};\n    const errors = [];\n    for (const selector in this.rules) {\n      const value = this.element.querySelector(selector).value;\n      const validator = this.rules[selector];\n      if (!validator.validate(value)) {\n        errors.push({ field: selector, messages: validator.getErrors() });\n      } else {\n        values[validator.fieldAlias ?? selector] = value;\n      }\n    }\n\n    if (errors.length > 0) {\n      this.triggerEvent('error', errors);\n    } else {\n      this.triggerEvent('success', values);\n    }\n  }\n\n  /**\n   * Triggers an event with the specified name and data.\n   * @param {string} name - The name of the event to trigger.\n   * @param {*} data - The data to pass to the event callbacks.\n   */\n  triggerEvent(name, data) {\n    if (this.events[name]) {\n      this.events[name].forEach(callback => callback(data));\n    }\n  }\n\n  /**\n   * Validates the form when it is submitted, preventing default form submission if specified.\n   * @param {boolean} [prevent=true] - Whether to prevent the default form submission.\n   */\n  validateWhenSubmit(prevent = true) {\n    this.element.addEventListener(\"submit\", function(event) {\n      if (prevent) event.preventDefault();\n      this.validate();\n    }.bind(this));\n  }\n}\n\n/**\n * Class representing the form module in the application.\n */\nexport class TurtleFormModule {\n  /**\n   * Creates an instance of the form module.\n   * @param {Object} app - The application instance.\n   * @param {Object} configs - Configuration options for the form module.\n   */\n  constructor(app, configs) {\n    this._app = app;\n    this._app.modules.push(this);\n    this._app.form = this;\n    this.configs = configs;\n  }\n\n  /**\n   * Initializes the form module.\n   * @param {Object} app - The application instance.\n   * @param {Object} configs - Configuration options for the form module.\n   * @returns {TurtleFormModule} The initialized form module.\n   */\n  static init(app, configs) {\n    return new TurtleFormModule(app, configs);\n  }\n\n  /**\n   * Creates a form validator for a specified form element.\n   * @param {HTMLElement} element - The form element to validate.\n   * @returns {TurtleFormModuleValidator} The form validator instance.\n   */\n  createFormValidator(element) {\n    return new TurtleFormModuleValidator(this, element);\n  }\n}","/**\n * Dynamically loads a script into the document.\n *\n * @param {string} src - The source URL of the script to load.\n * @param {boolean} [asyncLoad=false] - Whether to load the script asynchronously.\n * @param {boolean} [module=false] - Whether the script should be loaded as a JavaScript module.\n * @param {HTMLScriptElement} [script] - The script element that will be created (optional).\n * @returns {Promise<void>} - A promise that resolves when the script is loaded, or rejects on error.\n */\nexport function addScript(src, asyncLoad = false, module = false, script) {\n  let d = document;\n  return new Promise((resolve, reject) => {\n    script = d.createElement('script');\n    script.type = 'text/javascript';\n    if (module) script.type = 'module';\n    script.async = asyncLoad;\n    script.onload = function() {\n      resolve();\n    };\n    script.onerror = function() {\n      reject(new Error(`Failed to load script: ${src}`));\n    };\n    script.src = src;\n    d.getElementsByTagName('body')[0].appendChild(script);\n  });\n}\n\n/**\n * Ensures that a namespace is available in the given context by dynamically loading a script if needed.\n *\n * @param {string} name - The name of the namespace to check.\n * @param {Object} context - The context in which to check for the namespace (usually the global object).\n * @param {string} path - The path to the script that defines the namespace.\n * @param {boolean} defer - Whether to defer loading of the script.\n * @param {boolean} [module=false] - Whether the script should be loaded as a JavaScript module.\n * @param {boolean} [raise=false] - Whether to throw an error if the script fails to load.\n * @returns {Promise<void>} - A promise that resolves when the namespace is available.\n */\nexport async function ensureNamespace(name, context, path, defer, module = false, raise = false) {\n  if (!(name in context)) {\n    try {\n      await addScript(path, defer, module);\n    } catch (error) {\n      if (raise) {\n        throw new Error(`Failed to ensure namespace: ${name} - ${error.message}`);\n      }\n    }\n  }\n}","/**\n * Creates a throttled function that only invokes the provided function at \n * most once per specified time interval.\n *\n * @param {Function} func - The function to throttle.\n * @param {number} limit - The time interval in milliseconds to limit the \n *                         function calls.\n * @returns {Function} A new throttled function.\n *\n * @example\n * const handleScroll = throttle(() => {\n *   console.log('Scroll event triggered');\n * }, 1000);\n *\n * window.addEventListener('scroll', handleScroll);\n */\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n\n  return function(...args) {\n    const context = this;\n\n    if (!lastRan) {\n      func.apply(context, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(function() {\n        if ((Date.now() - lastRan) >= limit) {\n          func.apply(context, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function \n * until after a specified delay period has elapsed since the last time the \n * debounced function was invoked.\n *\n * @param {Function} func - The function to debounce.\n * @param {number} delay - The number of milliseconds to delay.\n * @returns {Function} A new debounced function.\n *\n * @example\n * const handleResize = debounce(() => {\n *   console.log('Resize event triggered');\n * }, 200);\n *\n * window.addEventListener('resize', handleResize);\n */\nfunction debounce(func, delay) {\n  let timeoutId;\n\n  return function(...args) {\n    if (timeoutId) clearTimeout(timeoutId);\n\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexport const performance = {\n  debounce,\n  throttle\n};","window.__TURTLE__={\n  dev:false,\n  version:\"2.0.0\"\n}\n\nexport * from \"./component/base.js\"\nexport * from \"./component/component.js\"\nexport * from \"./render/data.js\"\nexport * from \"./service/service.js\"\nexport * from \"./context/context.js\"\nexport * from \"./app/app.js\"\nexport * from \"./modules/index.js\"\nexport * from \"./features/index.js\"\nexport {TurtleRenderHelper} from \"./render/render.js\"","import {initDevMode} from \"./dev/dev.js\"\n\nif(!window.__TURTLE__.dev){\n  window.__TURTLE__.dev = true\n  initDevMode()\n}\n\nexport * from \"./index.js\"\nexport * from \"./dev/emitter.js\"\nexport * as TurtleDevEvents from \"./dev/events.js\"","import { initListener } from './listeners.js';\n\n/**\n * Initializes the Turtle Development Mode.\n * \n * This function checks if the development mode is enabled in the Turtle framework.\n * If so, it sets up logging for development tools, initializes tracking for apps and components,\n * and activates additional debugging features.\n */\nexport function initDevMode() {\n  if (window.__TURTLE__.dev) {\n    console.info(\"Turtle Development Mode is activated !\");\n    console.info(\"In development mode, you can access additional debugging tools and features.\");\n\n    // Initialize the development tracking object\n    window.__TURTLE_DEV__ = {\n      apps: {},\n      components: {},\n    };\n\n    console.info(\"Tracking initialized. Use window.__TURTLE_DEV__.apps and window.__TURTLE_DEV__.components to monitor your applications and components.\");\n\n    // Initialize event listeners for debugging\n    initListener();\n  }\n}","import * as TurtleDevEvents from './events.js';\n\n/**\n * Initializes the event listener for Turtle development events.\n * This function listens for the \"turtledev\" custom event and processes \n * the details according to the event type.\n */\nexport async function initListener() {\n  window.addEventListener(\"turtledev\", function(event) {\n    let details = event.detail;\n    let eventName = details.name;\n    let data = details.data;\n    let ID = (Math.floor(Math.random() * 99999999) * Date.now()).toString(32);\n\n    switch (eventName) {\n      case TurtleDevEvents.APP_INIT:\n        if (!data._turtle_dev_id) {\n          data._turtle_dev_id = ID;\n          data._turtle_dev_data = {\n            type: \"app\",\n            verify: true,\n            status: \"init\",\n            target: data\n          };\n        }\n        window.__TURTLE_DEV__.apps[data._turtle_dev_id] = data;\n        break;\n\n      case TurtleDevEvents.COMPONENT_INIT:\n        if (!data._turtle_dev_id) {\n          data._turtle_dev_id = ID;\n          data._turtle_dev_data = {\n            type: \"component\",\n            verify: true,\n            status: \"init\",\n            target: data\n          };\n        }\n        window.__TURTLE_DEV__.components[data._turtle_dev_id] = data;\n        break;\n\n      default:\n        // Uncomment to throw an error for unknown dev events\n        // throw \"[Turtle Dev Error] Unknown dev event!\";\n    }\n  });\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\nimport { render } from '../render/render.js';\nimport { TurtleRenderData } from '../render/data.js';\nimport { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n\n /**\n * Class representing the main application for the Turtle library.\n */\nexport class TurtleApp {\n  /**\n   * Creates an instance of TurtleApp.\n   * @param {Object} [configs={}] - Configuration options for the app.\n   */\n  constructor(configs = {}) {\n    this.root = null;\n    this.configs = configs;\n    this._contexts = {};\n    this.modules = [];\n    this.contexts = new TurtleContextManagement(null, this);\n    emitDevEvent(TURTLE_DEV_EVENTS.APP_INIT, this);\n  }\n\n  /**\n   * Initializes and uses a specified module.\n   * @param {Object} module - The module to be initialized.\n   * @param {Object} [configs] - Configuration options for the module.\n   * @returns {*} The result of the module's initialization.\n   */\n  useModule(module, configs) {\n    return module.init(this, configs);\n  }\n\n  /**\n   * Retrieves a context by its name.\n   * @param {string} name - The name of the context.\n   * @returns {TurtleContext|null} The context associated with the given name, or null if not found.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Attaches a context to the app by name.\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - An instance of TurtleContext to attach.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.use(name, context);\n  }\n\n  /**\n   * Attaches the specified HTML element as the root for rendering.\n   * @param {HTMLElement} element - The HTML element to use as the root.\n   * @throws {Error} Throws an error if the element is not an instance of HTMLElement.\n   */\n  attach(element) {\n    emitDevEvent(TURTLE_DEV_EVENTS.APP_ATTACHED, this);\n    if (element instanceof HTMLElement) {\n      this.root = element;\n    } else {\n      throw new Error('[Turtle Render Error] Element must be an instance of HTMLElement');\n    }\n  }\n\n  /**\n   * Renders the provided raw content and values into the root element.\n   * @param {TemplateStringsArray} raw - A template string containing the static parts of the template.\n   * @param {...*} values - Values to be interpolated into the template.\n   * @throws {Error} Throws an error if the root element is not attached.\n   */\n  render(raw, ...values) {\n    if (!this.root) {\n      throw new Error('[Turtle Render Error] Root element is not attached. Please attach a root element before rendering.');\n    }\n\n    this.root.textContent = \"\";\n    this.root.appendChild(render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(this), this));\n  }\n  \n  fragment(raw,...values){\n    return render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(this), this)\n  }\n  \n}","import { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n/**\n * Represents a service that manages contexts and methods for an entity.\n */\nexport class TurtleService {\n  /**\n   * Creates an instance of TurtleService.\n   *\n   * @param {Object} entity - The entity that this service will manage.\n   */\n  constructor(entity) {\n    this.entity = entity;\n    this.methods = {};\n    this._contexts = {};\n    this.contexts = new TurtleContextManagement(this.entity, this);\n  }\n\n  /**\n   * Uses a context by name and sets it in the service.\n   *\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - The context to set, must be an instance of TurtleContext.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.set(name, context);\n  }\n\n  /**\n   * Retrieves a context by name.\n   *\n   * @param {string} name - The name of the context to retrieve.\n   * @returns {TurtleContext|null} The context associated with the given name, or null if not found.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Defines a method with a name and a callback.\n   *\n   * @param {string} name - The name of the method to define.\n   * @param {Function} callback - The callback function to be executed when the method is called.\n   */\n  define(name, callback) {\n    this.methods[name] = callback.bind(this);\n  }\n\n  /**\n   * Calls and returns all defined methods.\n   *\n   * @returns {Object} An object containing all defined methods.\n   */\n  call() {\n    return this.methods;\n  }\n}"],"names":["APP_INIT","APP_ATTACHED","COMPONENT_INIT","COMPONENT_ATTACHED","COMPONENT_UPDATED","COMPONENT_RENDERED","emitDevEvent","name","data","window","__TURTLE__","dev","dispatchEvent","CustomEvent","detail","TurtleComponentElement","HTMLElement","constructor","super","this","app","component","attach","parent","contexts","element","TURTLE_DEV_EVENTS.COMPONENT_ATTACHED","connectedCallback","onInit","start","onCreate","startRender","disconnectedCallback","onDestroy","customElements","define","TurtleRenderData","root","document","createDocumentFragment","refs","bindings","events","addBinding","state","configs","push","addRef","Error","getRef","ref","removeRef","TurtleComponentRef","forwardRefs","extractName","startsWith","substring","length","applyDirective","target","value","context","passed","prefix","directives","ename","DirectiveClass","directiveInstance","apply","addEventListener","bind","type","thtml","ttext","processAttribute","node","attribute","Array","from","attributes","setAttribute","process","tree","childNodes","nodeType","Node","TEXT_NODE","appendChild","ELEMENT_NODE","components","nodeName","componentElement","createElement","getAttribute","newElement","tagName","render","template","raw","values","i","key","Math","floor","random","Date","now","toString","TurtleComponent","instance","content","doc","DOMParser","parseFromString","parserError","getElementsByTagName","errorMessage","textContent","console","log","parseHTML","String","TurtleComponentState","reactive","get","set","watchers","requestUpdate","sync","TurtleContext","_bindings","_values","_events","_isLocal","_reactive","bond","on","callback","off","filter","cb","emit","forEach","TurtleContextManagement","isChildAccess","_contexts","use","isLocal","warn","props","states","renderContext","TURTLE_DEV_EVENTS.COMPONENT_INIT","useContext","getContext","createState","setState","getState","html","setupState","setupWatcher","setupForwardRef","onRender","onUpdate","commit","TURTLE_DEV_EVENTS.COMPONENT_UPDATED","requestRender","fragment","TURTLE_DEV_EVENTS.COMPONENT_RENDERED","initStates","stateName","createComponent","fn","TurtleRouteComponent","matched","routes","isArray","path","p","active","router","status","match","Object","keys","currentPath","TurtleRoute","TurtleRouterModule","_app","modules","url","params","query","URLSearchParams","notallow","notfound","pagematches","pageloaded","pagechange","event","idx","splice","init","patterns","URL","location","origin","pathname","route","routeSplited","split","urlSplited","undefined","matches","u","emitEvent","j","searchParams","Function","protect","triggerError","loader","ctx","renderContent","started","hash","slice","redirect","replace","history","replaceState","TurtleFormModuleValidator","module","_module","rules","validate","errors","selector","querySelector","validator","fieldAlias","field","messages","getErrors","triggerEvent","validateWhenSubmit","prevent","preventDefault","TurtleFormModule","form","createFormValidator","addScript","src","asyncLoad","script","d","Promise","resolve","reject","async","onload","onerror","performance","debounce","func","delay","timeoutId","args","clearTimeout","setTimeout","throttle","limit","lastFunc","lastRan","version","info","__TURTLE_DEV__","apps","details","eventName","ID","TurtleDevEvents.APP_INIT","_turtle_dev_id","_turtle_dev_data","verify","TurtleDevEvents.COMPONENT_INIT","initListener","TURTLE_DEV_EVENTS.APP_INIT","useModule","TURTLE_DEV_EVENTS.APP_ATTACHED","validations","alias","rule","isNotNull","trim","maxLength","max","minLength","min","containsNumber","test","containsUppercase","containsLowercase","containsSpecialChar","isEmail","isPhoneNumber","isDate","isNaN","parse","isBefore","date","isAfter","isInRange","matchesRegex","regex","isAlpha","isAlphaNumeric","isNumeric","isUrl","isEqualTo","compareValue","isNotEqualTo","endsWith","suffix","isPositiveNumber","Number","isNegativeNumber","isInteger","isFloat","includes","validation","raws","entity","methods","call","defer","raise","error","message"],"mappings":"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"}