{"version":3,"file":"production.turtle.min.mjs","sources":["../../src/dev/emitter.js","../../src/component/base.js","../../src/dev/events.js","../../src/render/data.js","../../src/component/ref.js","../../src/render/process.js","../../src/render/directives.js","../../src/render/render.js","../../src/render/parser.js","../../src/component/state.js","../../src/context/context.js","../../src/component/component.js","../../src/service/service.js","../../src/app/app.js","../../src/modules/router/components.js","../../src/modules/router/index.js","../../src/modules/form/index.js","../../src/features/loader.js","../../src/features/performance.js","../../src/index.js","../../src/production.js"],"sourcesContent":["/**\n * Emits a development event for the Turtle framework.\n *\n * This function creates and dispatches a custom event named \"turtledev\" \n * if the development mode is activated. The event includes the specified \n * event name and associated data as its detail.\n *\n * @param {string} name - The name of the event to emit.\n * @param {*} data - The data associated with the event.\n */\nexport function emitDevEvent(name, data) {\n  if (!window.__TURTLE__.dev) return;\n\n  window.dispatchEvent(new CustomEvent(\"turtledev\", {\n    detail: {\n      name,\n      data\n    }\n  }));\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\n/**\n * Custom element that represents a Turtle component in the DOM.\n * Extends HTMLElement to manage lifecycle and interaction with the Turtle component.\n */\nexport class TurtleComponentElement extends HTMLElement {\n  /**\n   * Creates an instance of TurtleComponentElement.\n   */\n  constructor() {\n    super();\n    this.app = null; // The Turtle application instance.\n    this.component = null; // The Turtle component instance.\n  }\n\n  /**\n   * Attaches a Turtle application and component to this custom element.\n   * @param {Object} app - The Turtle application instance.\n   * @param {Object} parent - The parent component or context of this component.\n   * @param {TurtleComponent} component - The Turtle component instance.\n   */\n  attach(app, parent, component) {\n    this.app = app;\n    this.component = component;\n    this.component.parent = parent;\n    this.component.contexts.parent = parent;\n    this.component.element = this;\n    this.component.app = app;\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_ATTACHED, component);\n  }\n\n  /**\n   * Lifecycle method called when the element is inserted into the DOM.\n   * Initializes and starts the attached component.\n   */\n  connectedCallback() {\n    this.component.onInit();\n    this.component.start();\n    this.component.onCreate();\n    this.component.startRender();\n  }\n\n  /**\n   * Lifecycle method called when the element is removed from the DOM.\n   * Can be used for cleanup operations if needed.\n   */\n  disconnectedCallback() {\n    this.component.onDestroy();\n    // Add any cleanup code here if necessary\n  }\n}\n\n// Define the custom element \"turtle-component\" with the TurtleComponentElement class.\nwindow.customElements.define(\"turtle-component\", TurtleComponentElement);","/**\n * @constant {string} APP_INIT - Event triggered when the application is initialized.\n */\nexport const APP_INIT = \"APP_INIT\";\n\n/**\n * @constant {string} APP_ATTACHED - Event triggered when the application is attached to the DOM.\n */\nexport const APP_ATTACHED = \"APP_ATTACHED\";\n\n/**\n * @constant {string} APP_DESTROYED - Event triggered when the application is destroyed.\n */\nexport const APP_DESTROYED = \"APP_DESTROYED\";\n\n/**\n * @constant {string} COMPONENT_INIT - Event triggered when a component is initialized.\n */\nexport const COMPONENT_INIT = \"COMPONENT_INIT\";\n\n/**\n * @constant {string} COMPONENT_ATTACHED - Event triggered when a component is attached to the DOM.\n */\nexport const COMPONENT_ATTACHED = \"COMPONENT_ATTACHED\";\n\n/**\n * @constant {string} COMPONENT_DESTROYED - Event triggered when a component is destroyed.\n */\nexport const COMPONENT_DESTROYED = \"COMPONENT_DESTROYED\";\n\n/**\n * @constant {string} COMPONENT_UPDATED - Event triggered when a component is updated.\n */\nexport const COMPONENT_UPDATED = \"COMPONENT_UPDATED\";\n\n/**\n * @constant {string} COMPONENT_RENDERED - Event triggered when a component is rendered.\n */\nexport const COMPONENT_RENDERED = \"COMPONENT_RENDERED\";","/**\n * Represents the rendering Data for Turtle components.\n * This class manages references, bindings, and events for rendering.\n */\nexport class TurtleRenderData {\n  /**\n   * Creates an instance of TurtleRenderData.\n   * \n   * @param {DocumentFragment} [root] - The root element for rendering. Defaults to a new DocumentFragment.\n   */\n  constructor(root) {\n    this.root = root ?? document.createDocumentFragment();\n    this.refs = {};\n    this.bindings = {};\n    this.events = {};\n  }\n\n  /**\n   * Adds a binding for a specific state.\n   * \n   * @param {string} state - The name of the state to bind.\n   * @param {Object} configs - Configuration object for the binding, which may include callback functions or parameters.\n   */\n  addBinding(state, configs) {\n    if (!this.bindings[state]) {\n      this.bindings[state] = [];\n    }\n    this.bindings[state].push(configs);\n  }\n\n  /**\n   * Adds a reference to a DOM element with a unique name.\n   * \n   * @param {string} name - The unique name for the reference.\n   * @param {HTMLElement} element - The DOM element to be referenced.\n   * @throws {Error} Throws an error if a reference with the same name already exists.\n   * @private\n   */\n  addRef(name, element) {\n    if (this.refs[name]) {\n      throw new Error(`[Turtle Render Error] Multiple elements are assigned the same ref, which is not allowed. Each ref must be unique to a single DOM element.`);\n    }\n\n    this.refs[name] = element;\n  }\n\n  /**\n   * Retrieves a referenced DOM element by its unique name.\n   * \n   * @param {string} name - The unique name for the reference.\n   * @returns {HTMLElement} - The referenced DOM element.\n   * @throws {Error} Throws an error if no reference with the given name exists.\n   */\n  getRef(name) {\n    const ref = this.refs[name];\n    if (!ref) {\n      throw new Error(`[Turtle Render Error] No ref found with the name: ${name}`);\n    }\n    return ref;\n  }\n\n  /**\n   * Removes a reference by its unique name.\n   * \n   * @param {string} name - The unique name for the reference to remove.\n   * @throws {Error} Throws an error if no reference with the given name exists.\n   */\n  removeRef(name) {\n    if (!this.refs[name]) {\n      throw new Error(`[Turtle Render Error] Cannot remove ref: No ref found with the name: ${name}`);\n    }\n    delete this.refs[name];\n  }\n}","/**\n * Represents a reference to the element associated with a Turtle component.\n */\nexport class TurtleComponentRef {\n  #element;\n\n  /**\n   * Creates an instance of TurtleComponentRef.\n   * @param {HTMLElement} element - The HTML element associated with the Turtle component.\n   */\n  constructor(element) {\n    if (!element) {\n      throw new Error('[Turtle Component Ref Error] An element must be provided.');\n    }\n    this.#element = element;\n  }\n\n  /**\n   * Gets the forward references of the component associated with the element.\n   * @returns {Object} The forward references of the component.\n   * @throws {Error} If the element does not have an associated component.\n   */\n  get component() {\n    if (!this.#element.component) {\n      throw new Error('[Turtle Component Ref Error] The element does not have an associated component.');\n    }\n    return this.#element.component.forwardRefs;\n  }\n\n  // You can add more methods here to interact with the component or element.\n}","import { EventDirective, BindingDirective, HTMLDirective, TextContentDirective, RefDirective } from './directives.js';\nimport { TurtleComponentRef } from '../component/ref.js';\n\n/**\n * Extracts the name from the directive based on the given prefix.\n *\n * @param {string} name - The name of the directive.\n * @param {string} start - The prefix to extract from the name.\n * @returns {string|null} The extracted name without the prefix, or null if the prefix is not found.\n */\nfunction extractName(name, start) {\n  if (name.startsWith(start)) return name.substring(start.length);\n  return null;\n}\n\n/**\n * Applies a directive based on its name and value to a target element.\n *\n * @param {HTMLElement} target - The target element to which the directive is applied.\n * @param {string} name - The name of the directive.\n * @param {string} value - The value associated with the directive.\n * @param {Object} context - The context in which the directive is applied.\n * @returns {boolean} Returns true if the directive was successfully applied, otherwise false.\n */\nfunction applyDirective(target, name, value, context) {\n  let passed = false;\n  for (let prefix in directives) {\n    const ename = extractName(name, prefix);\n    const DirectiveClass = directives[ename != null ? prefix : name];\n    if (!DirectiveClass) {\n      continue;\n    }\n    const directiveInstance = new DirectiveClass(target, ename, value, context);\n    if (typeof directiveInstance.apply === 'function') {\n      directiveInstance.apply();\n      passed = true;\n    }\n    break;\n  }\n  return passed;\n}\n\n// Map of directive prefixes to their corresponding classes\nconst directives = {\n  \"tevent-\": EventDirective,\n  \"tbind-\": BindingDirective,\n  \"thtml\": HTMLDirective,\n  \"ttext\": TextContentDirective,\n  \"ref\": RefDirective\n};\n\n/**\n * Processes attributes of a given node and applies directives accordingly.\n *\n * @param {HTMLElement} target - The target element to process attributes for.\n * @param {Element} node - The node from which to extract attributes.\n * @param {Object} context - The context in which the attributes are processed.\n * @param {Object} data - Additional data to be used during processing.\n */\nexport function processAttribute(target, node, context, data) {\n  for (let attribute of Array.from(node.attributes)) {\n    let name = attribute.name;\n    let value = attribute.value;\n    let isDirective = applyDirective(target, name, value, context);\n    if (!isDirective) {\n      target.setAttribute(name, value);\n    }\n  }\n}\n\n/**\n * Processes a DOM tree, creating elements and applying directives as needed.\n *\n * @param {HTMLElement} element - The parent element to which new elements are appended.\n * @param {Node} tree - The DOM tree to process.\n * @param {Object} context - The context for processing.\n * @param {Object} data - Additional data, including component mappings.\n * @param {Object} app - The application context for components.\n */\nexport function process(element, tree, context, data, app) {\n  for (let node of Array.from(tree.childNodes)) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      element.appendChild(node);\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      if (data.components[node.nodeName]) {\n        let component = data.components[node.nodeName];\n        let componentElement = document.createElement(\"turtle-component\");\n        componentElement.attach(app, context.root, component);\n        if (node.getAttribute(\"ref\")) {\n          context.addRef(\n            node.getAttribute(\"ref\"),\n            new TurtleComponentRef(componentElement)\n          );\n        }\n        element.appendChild(componentElement);\n      } else {\n        let newElement = document.createElement(node.tagName);\n        processAttribute(newElement, node, context, data);\n        if (node.childNodes.length > 0) process(newElement, node, context, data);\n        element.appendChild(newElement);\n      }\n    }\n  }\n}","/**\n * Represents an event directive for adding event listeners to a target element.\n */\nexport class EventDirective {\n  /**\n   * Creates an instance of EventDirective.\n   * \n   * @param {HTMLElement} target - The target element to attach the event listener to.\n   * @param {string} name - The name of the event to listen for.\n   * @param {string} value - The name of the method to call on the event.\n   * @param {Object} context - The context in which the event method is defined.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the event directive by adding the event listener to the target element.\n   */\n  apply() {\n    if (this.context.root[this.value]) {\n      this.target.addEventListener(this.name, this.context.root[this.value].bind(this.context.root));\n    }\n  }\n}\n\n/**\n * Represents a binding directive for binding attributes to a target element.\n */\nexport class BindingDirective {\n  /**\n   * Creates an instance of BindingDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind the attribute to.\n   * @param {string} name - The name of the attribute to bind.\n   * @param {string} value - The state name to bind to the attribute.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the binding directive by adding a binding for the attribute to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"attribute\",\n      name: this.name,\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents an HTML directive for binding innerHTML to a target element.\n */\nexport class HTMLDirective {\n  /**\n   * Creates an instance of HTMLDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind innerHTML to.\n   * @param {string} name - The name of the property (always 'innerHTML').\n   * @param {string} value - The state name to bind to innerHTML.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the HTML directive by adding a binding for innerHTML to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"property\",\n      name: \"innerHTML\",\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents a text content directive for binding textContent to a target element.\n */\nexport class TextContentDirective {\n  /**\n   * Creates an instance of TextContentDirective.\n   * \n   * @param {HTMLElement} target - The target element to bind textContent to.\n   * @param {string} name - The name of the property (always 'textContent').\n   * @param {string} value - The state name to bind to textContent.\n   * @param {Object} context - The context for the binding.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the text content directive by adding a binding for textContent to the target element.\n   */\n  apply() {\n    this.context.addBinding(this.value, {\n      type: \"property\",\n      name: \"textContent\",\n      state: this.value,\n      target: this.target\n    });\n  }\n}\n\n/**\n * Represents a reference directive for adding a reference to a DOM element.\n */\nexport class RefDirective {\n  /**\n   * Creates an instance of RefDirective.\n   * \n   * @param {HTMLElement} target - The target element to be referenced.\n   * @param {string} name - The name of the reference.\n   * @param {string} value - The unique name to assign to the reference.\n   * @param {Object} context - The context for managing references.\n   */\n  constructor(target, name, value, context) {\n    this.target = target;\n    this.name = name;\n    this.value = value;\n    this.context = context;\n  }\n\n  /**\n   * Applies the reference directive by adding a reference to the target element.\n   */\n  apply() {\n    this.context.addRef(this.value, this.target);\n  }\n}","import { TurtleRenderData } from './data.js';\nimport { TurtleComponent } from '../component/component.js';\nimport { parseHTML } from './parser.js';\nimport { process } from './process.js';\n\n/**\n * Renders a template by processing its raw HTML and inserting values into it.\n *\n * @param {HTMLElement} element - The parent element to which the rendered content will be appended.\n * @param {TemplateStringsArray} template - The template containing the raw HTML and associated values.\n * @param {TurtleRenderData} [context=new TurtleRenderData()] - The context for rendering, defaulting to a new instance.\n * @param {Object|null} [app=null] - The application context, optional parameter.\n * @returns {HTMLElement} The parent element after rendering the template.\n */\nexport function render(element, template, context = new TurtleRenderData(), app = null) {\n  let raw = template.raw; // Raw HTML string from the template\n  let values = template.values; // Values to be inserted into the raw HTML\n  let data = {\n    components: {} // Object to hold components being rendered\n  };\n\n  for (let i = 0; i < values.length; i++) {\n    let key = `turtle-component-${(Math.floor(Math.random() * 999999) * Date.now()).toString(16)}`;\n    if (values[i]) {\n      if (values[i] instanceof TurtleComponent) {\n        data.components[key] = values[i]; // Store the component\n        values[i] = key; // Replace component with its key in values\n      } else if (values[i].instance === TurtleComponent) {\n        data.components[key] = values[i]({}); // Call the instance function if it's a component\n        values[i] = key; // Replace instance with its key\n      }\n    }\n  }\n\n  let content = String.raw(raw, ...values);\n  let tree = parseHTML(content);\n\n  process(element, tree, context, data, app);\n\n  return element;\n}\n\nexport class TurtleRenderHelper{\n  constructor(app,root,context=new TurtleRenderData()){\n    this.app = app\n    this.context = context \n    this.root = root\n  }\n  \n  fragment(raw,...values){\n    return render(document.createDocumentFragment(), { raw, values }, this.context, this.app)\n  }\n  \n  render(raws,...values){\n    this.root.textContent = \"\"\n    this.root.appendChild(render(document.createDocumentFragment(), { raw, values }, this.context, this.app))\n  }\n}","/**\n * Parses a string of HTML content and wraps it in a root element.\n * \n * @param {string} content - The HTML content to parse.\n * @returns {Element|null} - Returns the root element if parsing is successful, or null if there is a parsing error.\n * @throws {Error} Throws an error if there is a parsing issue with detailed information.\n */\nexport function parseHTML(content) {\n  let parser = new DOMParser();\n  let doc = parser.parseFromString(`<root>${content}</root>`, \"text/xml\");\n  let parserError = doc.getElementsByTagName(\"parsererror\");\n\n  if (parserError.length > 0) {\n    const errorMessage = \"Rendering error: \" + parserError[0].textContent;\n    console.log(errorMessage);\n    throw new Error(errorMessage);\n  } else {\n    return doc.getElementsByTagName(\"root\")[0];\n  }\n}","/**\n * Represents a state for a Turtle component.\n * It holds the state name, value, and manages updates when the state changes.\n */\nexport class TurtleComponentState {\n\n  /**\n   * Creates an instance of TurtleComponentState.\n   * \n   * @param {string} name - The name of the state.\n   * @param {*} value - The initial value of the state.\n   * @param {Object} component - The component that the state is associated with.\n   */\n  constructor(name, value, component) {\n    this.name = name;\n    this.value = value;\n    this.component = component;\n    this.reactive = true;\n  }\n\n  /**\n   * Retrieves the current value of the state.\n   * \n   * @returns {*} The current value of the state.\n   */\n  get() {\n    return this.value;\n  }\n\n  /**\n   * Sets a new value for the state and triggers a component update if it's reactive.\n   * \n   * @param {*} value - The new value to set for the state.\n   * @returns {*} The updated value.\n   */\n  set(value) {\n    this.value = value;\n    // Trigger the watcher if one is defined for this state.\n    if (this.component.watchers[this.name]) {\n      this.component.watchers[this.name](value);\n    }\n    // Trigger a component update if the component and state are reactive.\n    if (this.component.reactive && this.reactive) {\n      this.component.requestUpdate({\n        state: this.name,\n        value: value\n      });\n    }\n\n    return value;\n  }\n\n  /**\n   * Synchronizes the state with a given context and key, establishing a binding.\n   * \n   * @param {Object} context - The context to bind the state to.\n   * @param {string} key - The key under which the state will be bound in the context.\n   * @returns {TurtleComponentState} The instance of the state for chaining.\n   */\n  sync(context, key) {\n    context.sync(key, this);\n    return this;\n  }\n}","/**\n * Represents a context for managing bindings and values in the Turtle framework.\n */\nexport class TurtleContext {\n  constructor() {\n    this._bindings = {};\n    this._values = {};\n    this._events = {};\n    this._isLocal = false;\n  }\n\n  /**\n   * Updates all reactive bindings for a given name with a new value.\n   * \n   * @param {string} name - The name of the binding to update.\n   * @param {*} value - The new value to set for the binding.\n   * @private\n   */\n  _reactive(name, value) {\n    if (!this._bindings[name]) this._bindings[name] = [];\n    for (const bond of this._bindings[name]) {\n      bond.set(value);\n    }\n  }\n\n  /**\n   * Sets a value for a given name and triggers reactive updates.\n   * \n   * @param {string} name - The name of the value to set.\n   * @param {*} value - The value to set.\n   */\n  set(name, value) {\n    this._values[name] = value;\n    this._reactive(name, value);\n  }\n\n  /**\n   * Retrieves the value for a given name.\n   * \n   * @param {string} name - The name of the value to retrieve.\n   * @returns {*} The value associated with the name.\n   */\n  get(name) {\n    return this._values[name];\n  }\n\n  /**\n   * Synchronizes a state with a given name, establishing a binding.\n   * \n   * @param {string} name - The name to bind the state to.\n   * @param {Object} state - The state object to bind.\n   */\n  sync(name, state) {\n    if (!this._bindings[name]) this._bindings[name] = [];\n    this._bindings[name].push(state);\n  }\n\n  /**\n   * Registers an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to execute when the event occurs.\n   */\n  on(name, callback) {\n    if (!this._events[name]) {\n      this._events[name] = [];\n    }\n    this._events[name].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(name, callback) {\n    if (this._events[name]) {\n      this._events[name] = this.events[name].filter(cb => cb !== callback);\n    }\n  }\n\n  /**\n   * Triggers an event with the specified name and data.\n   * @param {string} name - The name of the event to trigger.\n   * @param {*} data - The data to pass to the event callbacks.\n   */\n  emit(name, data) {\n    if (this._events[name]) {\n      this._events[name].forEach(callback => callback(data));\n    }\n  }\n}\n\n/**\n * Manages context retrieval and usage in the Turtle framework.\n */\nexport class TurtleContextManagement {\n  constructor(parent, target) {\n    this.parent = parent;\n    this.target = target;\n  }\n\n  /**\n   * Retrieves a context by its name, optionally allowing child access.\n   * \n   * @param {string} name - The name of the context to retrieve.\n   * @param {boolean} isChildAccess - Whether to allow access to child contexts.\n   * @returns {TurtleContext|null} The requested context or null if not found.\n   */\n  get(name, isChildAccess = false) {\n    if (this.target._contexts[name] && (isChildAccess && this.target._contexts[name]._isLocal)) {\n      return null;\n    }\n\n    if (this.target._contexts[name]) {\n      return this.target._contexts[name];\n    } else if (this.parent) {\n      return this.parent.contexts.get(name, true);\n    }\n  }\n\n  /**\n   * Uses a context with a given name and associates it with the target.\n   * \n   * @param {string} name - The name of the context to use.\n   * @param {TurtleContext} context - The context to use.\n   * @param {boolean} isLocal - Indicates whether the context is local.\n   */\n  use(name, context, isLocal = false) {\n    if (this.target._contexts[name] || (this.parent && this.parent.contexts.get(name))) {\n      console.warn(`[Turtle Data Warning] Context key \"${name}\" already exists. The existing context will be overwritten.`);\n    }\n    this.target._contexts[name] = context;\n    this.target._contexts[name]._isLocal = isLocal;\n  }\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\nimport { render } from '../render/render.js';\nimport { TurtleRenderData } from '../render/data.js';\nimport { TurtleComponentState } from './state.js';\nimport { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n/**\n * Represents a Turtle Component.\n */\nexport class TurtleComponent {\n  /**\n   * Creates an instance of TurtleComponent.\n   * @param {Object} props - The properties passed to the component.\n   */\n  constructor(props) {\n    this.parent = null;\n    this.app = null;\n    this.element = null;\n    this.props = props;\n    this.watchers = {};\n    this.forwardRefs = {};\n    this.states = {};\n    this.reactive = true;\n    this._contexts = {};\n    this.contexts = new TurtleContextManagement(this.parent, this);\n    this.renderContext = new TurtleRenderData(this);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_INIT, this);\n  }\n\n  /**\n   * Registers a context for use within the component.\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - The context instance.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context,isLocal=false) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.use(name, context,isLocal);\n    return context\n  }\n\n  /**\n   * Retrieves a context by name.\n   * @param {string} name - The name of the context.\n   * @returns {TurtleContext} The requested context instance.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Gets the references from the render context.\n   * @returns {Object} The refs object.\n   */\n  get refs() {\n    return this.renderContext.refs;\n  }\n\n  /**\n   * Creates a new state for the component.\n   * @param {string} name - The name of the state.\n   * @param {*} value - The initial value of the state.\n   * @returns {TurtleComponentState} The created state object.\n   */\n  createState(name, value) {\n    let state = new TurtleComponentState(name, value, this);\n    this.states[name] = state;\n    return state;\n  }\n\n  /**\n   * Sets the state of the component.\n   * @param {string} name - The name of the state.\n   * @param {*} value - The new value of the state.\n   */\n  setState(name, value) {\n    if (!this.states[name]) {\n      this.states[name] = new TurtleComponentState(name, value, this);\n    }\n    this.states[name].set(value);\n  }\n\n  /**\n   * Gets the value of a specific state.\n   * @param {string} name - The name of the state.\n   * @returns {*} The value of the state.\n   */\n  getState(name) {\n    return this.states[name].get();\n  }\n\n  /**\n   * Gets the state object by its name.\n   * @param {string} name - The name of the state.\n   * @returns {TurtleComponentState} The state object.\n   */\n  state(name) {\n    return this.states[name];\n  }\n\n  /**\n   * Creates a fragment using a template literal and values.\n   * @param {TemplateStringsArray} raw - The raw template literal.\n   * @param {...*} values - The values to be used in the template.\n   * @returns {DocumentFragment} The rendered HTML as a DocumentFragment.\n   */\n  html(raw, ...values) {\n    let fragment = render(document.createDocumentFragment(), { raw, values }, this.renderContext, this.app);\n    return fragment;\n  }\n\n  /**\n   * Sets up the initial states for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing initial state values.\n   */\n  setupState() {\n    return {};\n  }\n\n  /**\n   * Sets up watchers for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing watcher functions.\n   */\n  setupWatcher() {\n    return {};\n  }\n\n  /**\n   * Sets up forward references for the component.\n   * Should be overridden by subclasses.\n   * @returns {Object} An object containing forward references.\n   */\n  setupForwardRef() {\n    return {};\n  }\n\n  /**\n   * Lifecycle method called when the component is initialized.\n   * Should be overridden by subclasses.\n   */\n  onInit() {}\n\n  /**\n   * Lifecycle method called when the component is created.\n   * Should be overridden by subclasses.\n   */\n  onCreate() {}\n\n  /**\n   * Lifecycle method called when the component is destroyed.\n   * Should be overridden by subclasses.\n   */\n  onDestroy() {}\n\n  /**\n   * Lifecycle method called after the component is rendered.\n   * Should be overridden by subclasses.\n   */\n  onRender() {}\n\n  /**\n   * Lifecycle method called when the component is updated.\n   * Should be overridden by subclasses.\n   * @param {Object} commit - The commit object representing state changes.\n   */\n  onUpdate(commit) {}\n\n  /**\n   * Returns the template of the component.\n   * Should be overridden by subclasses.\n   * @returns {DocumentFragment} The template as a DocumentFragment.\n   */\n  template() {}\n\n  /**\n   * Requests an update for the component and triggers the onUpdate lifecycle method.\n   * @param {Object} commit - The commit object representing state changes.\n   * @returns {Promise<void>}\n   */\n  async requestUpdate(commit) {\n    this._reactive(commit);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_UPDATED, this);\n    this.onUpdate(commit);\n  }\n\n  /**\n   * Requests a render for the component using its template.\n   * @returns {Promise<void>}\n   */\n  async requestRender() {\n    let fragment = this.template();\n    this.element.textContent = \"\";\n    this.element.appendChild(fragment);\n    emitDevEvent(TURTLE_DEV_EVENTS.COMPONENT_RENDERED, this);\n    this.onRender();\n  }\n\n  /**\n   * Handles reactivity for state changes.\n   * @param {Object} commit - The commit object representing state changes.\n   */\n  _reactive(commit) {\n    let bindings = this.renderContext.bindings[commit.state];\n    if (!bindings) return;\n    for (let bind of bindings) {\n      if (bind.type === \"property\") bind.target[bind.name] = commit.value;\n      if (bind.type === \"attribute\") bind.target.setAttribute(bind.name, commit.value);\n    }\n  }\n\n  /**\n   * Initializes the states for the component.\n   * @param {Object} states - An object containing state names and initial values.\n   */\n  initStates(states) {\n    for (let stateName in states) {\n      this.states[stateName] = new TurtleComponentState(stateName, states[stateName], this);\n    }\n  }\n\n  /**\n   * Starts the component by setting up forward references, watchers, and states, then requests a render.\n   */\n  start() {\n    this.forwardRefs = this.setupForwardRef() ?? {};\n    this.watchers = this.setupWatcher() ?? {};\n    this.initStates(this.setupState() ?? {});\n    \n  }\n  \n  startRender(){\n    this.requestRender();\n  }\n}\n\n/**\n * Creates a new TurtleComponent instance.\n * @param {Function} constructor - The constructor function for the TurtleComponent.\n * @returns {Function} A function that creates an instance of the specified component.\n */\nexport function createComponent(constructor) {\n  /**\n   * Initializes the component with the given properties.\n   * @param {Object} props - The properties to be passed to the component.\n   * @returns {TurtleComponent} The instantiated component.\n   */\n  function fn(...props) {\n    let component = new constructor(props);\n    component.props = props;\n    return component;\n  }\n\n  fn.instance = TurtleComponent;\n  return fn;\n}","import { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n/**\n * Represents a service that manages contexts and methods for an entity.\n */\nexport class TurtleService {\n  /**\n   * Creates an instance of TurtleService.\n   *\n   * @param {Object} entity - The entity that this service will manage.\n   */\n  constructor(entity) {\n    this.entity = entity;\n    this.methods = {};\n    this._contexts = {};\n    this.contexts = new TurtleContextManagement(this.entity, this);\n  }\n\n  /**\n   * Uses a context by name and sets it in the service.\n   *\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - The context to set, must be an instance of TurtleContext.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.set(name, context);\n  }\n\n  /**\n   * Retrieves a context by name.\n   *\n   * @param {string} name - The name of the context to retrieve.\n   * @returns {TurtleContext|null} The context associated with the given name, or null if not found.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Defines a method with a name and a callback.\n   *\n   * @param {string} name - The name of the method to define.\n   * @param {Function} callback - The callback function to be executed when the method is called.\n   */\n  define(name, callback) {\n    this.methods[name] = callback.bind(this);\n  }\n\n  /**\n   * Calls and returns all defined methods.\n   *\n   * @returns {Object} An object containing all defined methods.\n   */\n  call() {\n    return this.methods;\n  }\n}","import { emitDevEvent } from '../dev/emitter.js';\nimport * as TURTLE_DEV_EVENTS from '../dev/events.js';\n\nimport { render } from '../render/render.js';\nimport { TurtleRenderData } from '../render/data.js';\nimport { TurtleContextManagement, TurtleContext } from '../context/context.js';\n\n\n /**\n * Class representing the main application for the Turtle library.\n */\nexport class TurtleApp {\n  /**\n   * Creates an instance of TurtleApp.\n   * @param {Object} [configs={}] - Configuration options for the app.\n   */\n  constructor(configs = {}) {\n    this.root = null;\n    this.configs = configs;\n    this._contexts = {};\n    this.modules = [];\n    this.contexts = new TurtleContextManagement(null, this);\n    emitDevEvent(TURTLE_DEV_EVENTS.APP_INIT, this);\n  }\n\n  /**\n   * Initializes and uses a specified module.\n   * @param {Object} module - The module to be initialized.\n   * @param {Object} [configs] - Configuration options for the module.\n   * @returns {*} The result of the module's initialization.\n   */\n  useModule(module, configs) {\n    return module.init(this, configs);\n  }\n\n  /**\n   * Retrieves a context by its name.\n   * @param {string} name - The name of the context.\n   * @returns {TurtleContext|null} The context associated with the given name, or null if not found.\n   */\n  getContext(name) {\n    return this.contexts.get(name);\n  }\n\n  /**\n   * Attaches a context to the app by name.\n   * @param {string} name - The name of the context.\n   * @param {TurtleContext} context - An instance of TurtleContext to attach.\n   * @throws {Error} Throws an error if the context is not an instance of TurtleContext.\n   */\n  useContext(name, context) {\n    if (!(context instanceof TurtleContext)) {\n      throw new Error('[Turtle Data Error] Context must be an instance of TurtleContext');\n    }\n    this.contexts.use(name, context);\n  }\n\n  /**\n   * Attaches the specified HTML element as the root for rendering.\n   * @param {HTMLElement} element - The HTML element to use as the root.\n   * @throws {Error} Throws an error if the element is not an instance of HTMLElement.\n   */\n  attach(element) {\n    emitDevEvent(TURTLE_DEV_EVENTS.APP_ATTACHED, this);\n    if (element instanceof HTMLElement) {\n      this.root = element;\n    } else {\n      throw new Error('[Turtle Render Error] Element must be an instance of HTMLElement');\n    }\n  }\n\n  /**\n   * Renders the provided raw content and values into the root element.\n   * @param {TemplateStringsArray} raw - A template string containing the static parts of the template.\n   * @param {...*} values - Values to be interpolated into the template.\n   * @throws {Error} Throws an error if the root element is not attached.\n   */\n  render(raw, ...values) {\n    if (!this.root) {\n      throw new Error('[Turtle Render Error] Root element is not attached. Please attach a root element before rendering.');\n    }\n\n    this.root.textContent = \"\";\n    this.root.appendChild(render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(this), this));\n  }\n  \n  fragment(raw,...values){\n    return render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(this), this)\n  }\n  \n}","import { TurtleComponent, createComponent } from '../../component/component.js';\n\nexport class TurtleRouteComponent extends TurtleComponent {\n  constructor(props) {\n    super(props)\n    this.matched = false\n  }\n\n  onInit() {\n    const [routes] = this.props;\n\n    if (Array.isArray(routes)) {\n      this.routes = {};\n      routes.forEach(({ component, path }) => {\n        if (Array.isArray(path)) {\n          path.forEach(p => this.routes[p] = component);\n        } else {\n          this.routes[path] = component;\n        }\n      });\n    } else if (typeof routes === \"object\") {\n      this.routes = routes;\n    }\n\n  }\n\n  active() {\n    if (this.app.router) {\n      let router = this.app.router\n      let [status, matched] = router.match(Object.keys(this.routes), router.currentPath())\n      if ((status) && !this.matched) {\n        this.matched = true\n        this.element.appendChild(this.html`\n          <${this.routes[matched]}/>\n        `)\n      }\n      if (!status) {\n        this.matched = false\n        this.element.textContent = \"\"\n      }\n    }\n  }\n\n  onRender() {\n    this.active()\n    if (this.app.router) {\n      this.app.router.on(\"pagechange\", this.active.bind(this))\n    }\n  }\n\n  template() {\n    return this.html``\n  }\n}\n\n\nexport const TurtleRoute = createComponent(TurtleRouteComponent)","import { render } from '../../render/render.js';\nimport { TurtleRenderData } from '../../render/data.js';\n\n/**\n * TurtleRouterModule manages routing in a Turtle application.\n * It handles matching routes, invoking callbacks, and rendering components based on URLs.\n */\nexport class TurtleRouterModule {\n\n  /**\n   * Creates a new TurtleRouterModule instance.\n   *\n   * @param {Object} app - The Turtle app instance this router is attached to.\n   * @param {Object} configs - Configuration for the router, including the root element.\n   */\n  constructor(app, configs) {\n    this.root = configs.element ?? document.createElement(\"div\");\n    this._app = app;\n    this._app.modules.push(this);\n    this._app.router = this;\n    this.routes = {};\n    this.matched = null;\n    this.url = null;\n    this.params = {};\n    this.query = new URLSearchParams();\n    this.events = {\n      notallow: [],\n      notfound: [],\n      pagematches: [],\n      pageloaded: [],\n      pagechange: []\n    };\n  }\n\n  /**\n   * Registers an event listener for a specific router event.\n   *\n   * @param {string} event - The name of the event (e.g., 'pagechange', 'notfound').\n   * @param {function} callback - The function to call when the event is triggered.\n   */\n  on(event, callback) {\n    this.events[event].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specific router event.\n   *\n   * @param {string} event - The name of the event.\n   * @param {function} callback - The callback function to remove.\n   */\n  off(event, callback) {\n    this.events[event].forEach((fn, idx) => {\n      if (fn === callback) {\n        this.events[event].splice(idx, 1);\n      }\n    });\n  }\n\n  /**\n   * Initializes the TurtleRouterModule.\n   *\n   * @param {Object} app - The Turtle app instance.\n   * @param {Object} configs - Configuration for the router.\n   * @returns {TurtleRouterModule} - The initialized router module.\n   */\n  static init(app, configs) {\n    return new TurtleRouterModule(app, configs);\n  }\n\n  match(patterns, url) {\n    let u = new URL(url, window.location.origin);\n    url = u.pathname;\n\n    if (!patterns) return\n    for (let i = 0; i < patterns.length; i++) {\n      let route = patterns[i]\n      let routeSplited = route.split(\"/\");\n      let urlSplited = url.split(\"/\");\n      let passed = true;\n      let params = {};\n\n      if (urlSplited.length != routeSplited.length) {\n        passed = false;\n      } else {\n        for (let i = 0; i < routeSplited.length; i++) {\n          if (urlSplited[i] === undefined) {\n            passed = false;\n          }\n\n          if (routeSplited[i] == \"*\") {\n            break;\n          }\n\n          if (routeSplited[i][0] == \":\") {\n            let name = routeSplited[i].substring(1, routeSplited[i].length);\n            params[name] = urlSplited[i];\n            continue;\n          }\n\n          if (routeSplited[i] != urlSplited[i]) {\n            passed = false;\n          }\n        }\n      }\n      if (passed) return [true,route]\n    }\n    return [false,null]\n  }\n\n  /**\n   * Matches the provided URL against the router's routes.\n   *\n   * @param {string} url - The URL to match against the defined routes.\n   * @returns {Promise<void>} - A promise that resolves when the match is complete.\n   */\n  async matches(url) {\n    let u = new URL(url, window.location.origin);\n    url = u.pathname;\n    this.emitEvent(\"pagechange\", this);\n    for (let j = 0; j < Object.keys(this.routes).length; j++) {\n      let route = Object.keys(this.routes)[j];\n      let configs = this.routes[route];\n      let routeSplited = route.split(\"/\");\n      let urlSplited = url.split(\"/\");\n      let passed = true;\n      let params = {};\n\n      if (urlSplited.length != routeSplited.length) {\n        passed = false;\n      } else {\n        for (let i = 0; i < routeSplited.length; i++) {\n          if (urlSplited[i] === undefined) {\n            passed = false;\n          }\n\n          if (routeSplited[i] == \"*\") {\n            break;\n          }\n\n          if (routeSplited[i][0] == \":\") {\n            let name = routeSplited[i].substring(1, routeSplited[i].length);\n            params[name] = urlSplited[i];\n            continue;\n          }\n\n          if (routeSplited[i] != urlSplited[i]) {\n            passed = false;\n          }\n        }\n      }\n\n      if (passed) {\n        this.params = params;\n        this.query = u.searchParams;\n        this.matched = route;\n        this.url = url;\n        let component = new Function();\n        if (configs.callback) { await configs.callback(); }\n        if (configs.protect) {\n          let result = await configs.protect();\n          if (!result) {\n            this.triggerError(\"not_allow\");\n            return;\n          }\n        }\n        this.emitEvent(\"pagematches\", this);\n\n        if (configs.loader) {\n          component = await configs.loader();\n        }\n\n        if (configs.component) {\n          component = configs.component;\n        }\n        let ctx = this;\n        let element = this.root;\n\n        function renderContent(raw, ...values) {\n          element.textContent = \"\";\n          element.appendChild(render(document.createDocumentFragment(), { raw, values }, new TurtleRenderData(ctx._app), ctx._app));\n        }\n\n        this.emitEvent(\"pageloaded\", this);\n        return renderContent`<${component}/>`;\n      }\n    }\n\n    this.triggerError(\"not_found\");\n  }\n\n  /**\n   * Starts the router and listens for changes in the URL.\n   */\n  start() {\n    let started = false;\n    let path = window.location.hash;\n    if (path.length == 0) {\n      path = \"/\";\n      window.location = \"#\";\n    } else {\n      path = path.slice(2);\n    }\n\n    window.addEventListener(\"hashchange\", function() {\n      if (started) {\n        let path = window.location.hash;\n        if (path.length == 0) {\n          path = \"/\";\n        } else {\n          path = path.slice(2);\n        }\n\n        this.matches(path);\n      }\n    }.bind(this));\n    started = true;\n    this.matches(path);\n    started = true;\n  }\n\n  currentPath() {\n    let path = window.location.hash;\n    if (path.length == 0) {\n      path = \"/\";\n    } else {\n      path = path.slice(2);\n    }\n    return path\n  }\n\n  /**\n   * Redirects to a new route.\n   *\n   * @param {string} path - The path to navigate to.\n   * @param {boolean} [replace=false] - Whether to replace the current URL or push a new one.\n   */\n  redirect(path, replace = false) {\n    if (!replace) {\n      window.location.hash = `!${path}`;\n    } else {\n      window.history.replaceState(null, null, `./#!${path}`);\n      this.matches(path);\n    }\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param {string} name - The event name.\n   * @param {*} data - The data to pass with the event.\n   */\n  emitEvent(name, data) {\n    this.events[name].forEach(fn => {\n      fn(data);\n    });\n  }\n\n  /**\n   * Triggers a router error event.\n   *\n   * @param {string} name - The error event name (e.g., 'not_allow', 'not_found').\n   */\n  triggerError(name) {\n    switch (name) {\n      case 'not_allow':\n        this.emitEvent(\"notallow\", this);\n        break;\n\n      case 'not_found':\n        this.emitEvent(\"notfound\", this);\n        break;\n    }\n  }\n}\n\nexport * from \"./components.js\"","export class TurtleFormModuleValidatorRules {\n  /**\n   * Creates an instance of TurtleFormModuleValidatorRules.\n   */\n  constructor() {\n    this.validations = [];\n    this.errors = [];\n    this.fieldAlias = null;\n  }\n\n  /**\n   * Sets an alias for the field being validated.\n   * @param {string} name - The alias name for the field.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  alias(name) {\n    this.validations.push({\n      rule: (value) => true,\n    });\n    this.fieldAlias = name;\n    return this;\n  }\n\n  /**\n   * Validates that the value is not null or empty.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNotNull() {\n    this.validations.push({\n      rule: (value) => value !== null && value !== undefined && value.trim() !== \"\",\n      errorMessage: \"Value cannot be null or empty.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value does not exceed the specified maximum length.\n   * @param {number} max - The maximum allowed length of the value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  maxLength(max) {\n    this.validations.push({\n      rule: (value) => value.length <= max,\n      errorMessage: `Value must be at most ${max} characters long.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value meets the specified minimum length.\n   * @param {number} min - The minimum required length of the value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  minLength(min) {\n    this.validations.push({\n      rule: (value) => value.length >= min,\n      errorMessage: `Value must be at least ${min} characters long.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsNumber() {\n    this.validations.push({\n      rule: (value) => /\\d/.test(value),\n      errorMessage: \"Value must contain at least one number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one uppercase letter.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsUppercase() {\n    this.validations.push({\n      rule: (value) => /[A-Z]/.test(value),\n      errorMessage: \"Value must contain at least one uppercase letter.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one lowercase letter.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsLowercase() {\n    this.validations.push({\n      rule: (value) => /[a-z]/.test(value),\n      errorMessage: \"Value must contain at least one lowercase letter.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains at least one special character.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  containsSpecialChar() {\n    this.validations.push({\n      rule: (value) => /[!@#$%^&*(),.?\":{}|<>]/.test(value),\n      errorMessage: \"Value must contain at least one special character.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid email address.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isEmail() {\n    this.validations.push({\n      rule: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n      errorMessage: \"Value must be a valid email address.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid phone number in international format.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isPhoneNumber() {\n    this.validations.push({\n      rule: (value) => /^\\+?[1-9]\\d{1,14}$/.test(value),\n      errorMessage: \"Value must be a valid phone number in international format.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid date.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isDate() {\n    this.validations.push({\n      rule: (value) => !isNaN(Date.parse(value)),\n      errorMessage: \"Value must be a valid date.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the date is before a specified date.\n   * @param {string} date - The date to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isBefore(date) {\n    this.validations.push({\n      rule: (value) => new Date(value) < new Date(date),\n      errorMessage: `Date must be before ${date}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the date is after a specified date.\n   * @param {string} date - The date to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAfter(date) {\n    this.validations.push({\n      rule: (value) => new Date(value) > new Date(date),\n      errorMessage: `Date must be after ${date}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is within a specified range.\n   * @param {number} min - The minimum allowed value.\n   * @param {number} max - The maximum allowed value.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isInRange(min, max) {\n    this.validations.push({\n      rule: (value) => value >= min && value <= max,\n      errorMessage: `Value must be between ${min} and ${max}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value matches a specified regular expression.\n   * @param {RegExp} regex - The regular expression to test against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  matchesRegex(regex) {\n    this.validations.push({\n      rule: (value) => regex.test(value),\n      errorMessage: `Value must match the required pattern.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only alphabetic characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAlpha() {\n    this.validations.push({\n      rule: (value) => /^[a-zA-Z]+$/.test(value),\n      errorMessage: \"Value must contain only alphabetic characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only alphanumeric characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isAlphaNumeric() {\n    this.validations.push({\n      rule: (value) => /^[a-zA-Z0-9]+$/.test(value),\n      errorMessage: \"Value must contain only alphanumeric characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value contains only numeric characters.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNumeric() {\n    this.validations.push({\n      rule: (value) => /^[0-9]+$/.test(value),\n      errorMessage: \"Value must contain only numeric characters.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a valid URL.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isUrl() {\n    this.validations.push({\n      rule: (value) => /^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/.test(value),\n      errorMessage: \"Value must be a valid URL.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is equal to a specified value.\n   * @param {*} compareValue - The value to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isEqualTo(compareValue) {\n    this.validations.push({\n      rule: (value) => value === compareValue,\n      errorMessage: `Value must be equal to ${compareValue}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is not equal to a specified value.\n   * @param {*} compareValue - The value to compare against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNotEqualTo(compareValue) {\n    this.validations.push({\n      rule: (value) => value !== compareValue,\n      errorMessage: `Value must not be equal to ${compareValue}.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value starts with a specified prefix.\n   * @param {string} prefix - The prefix to check against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  startsWith(prefix) {\n    this.validations.push({\n      rule: (value) => value.startsWith(prefix),\n      errorMessage: `Value must start with '${prefix}'.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value ends with a specified suffix.\n   * @param {string} suffix - The suffix to check against.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  endsWith(suffix) {\n    this.validations.push({\n      rule: (value) => value.endsWith(suffix),\n      errorMessage: `Value must end with '${suffix}'.`\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a positive number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isPositiveNumber() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && Number(value) > 0,\n      errorMessage: \"Value must be a positive number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a negative number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isNegativeNumber() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && Number(value) < 0,\n      errorMessage: \"Value must be a negative number.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is an integer.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isInteger() {\n    this.validations.push({\n      rule: (value) => Number.isInteger(Number(value)),\n      errorMessage: \"Value must be an integer.\"\n    });\n    return this;\n  }\n\n  /**\n   * Validates that the value is a floating-point number.\n   * @returns {TurtleFormModuleValidatorRules} The current instance for chaining.\n   */\n  isFloat() {\n    this.validations.push({\n      rule: (value) => !isNaN(value) && value.toString().includes('.'),\n      errorMessage: \"Value must be a floating-point number.\"\n    });\n    return this;\n  }\n\n  validate(value) {\n    this.errors = [];\n    for (const validation of this.validations) {\n      if (!validation.rule(value)) {\n        this.errors.push(validation.errorMessage);\n      }\n    }\n    return this.errors.length === 0;\n  }\n\n  getErrors() {\n    return this.errors;\n  }\n\n}\n\n/**\n * Class representing a form validator module.\n */\nclass TurtleFormModuleValidator {\n  /**\n   * Creates an instance of the form validator.\n   * @param {Object} module - The module associated with the validator.\n   * @param {HTMLElement} element - The form element to validate.\n   */\n  constructor(module, element) {\n    this._module = module;\n    this.element = element;\n    this.events = {};\n    this.rules = {};\n  }\n\n  /**\n   * Registers an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to execute when the event occurs.\n   */\n  on(name, callback) {\n    if (!this.events[name]) {\n      this.events[name] = [];\n    }\n    this.events[name].push(callback);\n  }\n\n  /**\n   * Unregisters an event listener for a specified event name.\n   * @param {string} name - The name of the event.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(name, callback) {\n    if (this.events[name]) {\n      this.events[name] = this.events[name].filter(cb => cb !== callback);\n    }\n  }\n\n  /**\n   * Validates the form elements based on defined rules and triggers the appropriate events.\n   */\n  validate() {\n    const values = {};\n    const errors = [];\n    for (const selector in this.rules) {\n      const value = this.element.querySelector(selector).value;\n      const validator = this.rules[selector];\n      if (!validator.validate(value)) {\n        errors.push({ field: selector, messages: validator.getErrors() });\n      } else {\n        values[validator.fieldAlias ?? selector] = value;\n      }\n    }\n\n    if (errors.length > 0) {\n      this.triggerEvent('error', errors);\n    } else {\n      this.triggerEvent('success', values);\n    }\n  }\n\n  /**\n   * Triggers an event with the specified name and data.\n   * @param {string} name - The name of the event to trigger.\n   * @param {*} data - The data to pass to the event callbacks.\n   */\n  triggerEvent(name, data) {\n    if (this.events[name]) {\n      this.events[name].forEach(callback => callback(data));\n    }\n  }\n\n  /**\n   * Validates the form when it is submitted, preventing default form submission if specified.\n   * @param {boolean} [prevent=true] - Whether to prevent the default form submission.\n   */\n  validateWhenSubmit(prevent = true) {\n    this.element.addEventListener(\"submit\", function(event) {\n      if (prevent) event.preventDefault();\n      this.validate();\n    }.bind(this));\n  }\n}\n\n/**\n * Class representing the form module in the application.\n */\nexport class TurtleFormModule {\n  /**\n   * Creates an instance of the form module.\n   * @param {Object} app - The application instance.\n   * @param {Object} configs - Configuration options for the form module.\n   */\n  constructor(app, configs) {\n    this._app = app;\n    this._app.modules.push(this);\n    this._app.form = this;\n    this.configs = configs;\n  }\n\n  /**\n   * Initializes the form module.\n   * @param {Object} app - The application instance.\n   * @param {Object} configs - Configuration options for the form module.\n   * @returns {TurtleFormModule} The initialized form module.\n   */\n  static init(app, configs) {\n    return new TurtleFormModule(app, configs);\n  }\n\n  /**\n   * Creates a form validator for a specified form element.\n   * @param {HTMLElement} element - The form element to validate.\n   * @returns {TurtleFormModuleValidator} The form validator instance.\n   */\n  createFormValidator(element) {\n    return new TurtleFormModuleValidator(this, element);\n  }\n}","/**\n * Dynamically loads a script into the document.\n *\n * @param {string} src - The source URL of the script to load.\n * @param {boolean} [asyncLoad=false] - Whether to load the script asynchronously.\n * @param {boolean} [module=false] - Whether the script should be loaded as a JavaScript module.\n * @param {HTMLScriptElement} [script] - The script element that will be created (optional).\n * @returns {Promise<void>} - A promise that resolves when the script is loaded, or rejects on error.\n */\nexport function addScript(src, asyncLoad = false, module = false, script) {\n  let d = document;\n  return new Promise((resolve, reject) => {\n    script = d.createElement('script');\n    script.type = 'text/javascript';\n    if (module) script.type = 'module';\n    script.async = asyncLoad;\n    script.onload = function() {\n      resolve();\n    };\n    script.onerror = function() {\n      reject(new Error(`Failed to load script: ${src}`));\n    };\n    script.src = src;\n    d.getElementsByTagName('body')[0].appendChild(script);\n  });\n}\n\n/**\n * Ensures that a namespace is available in the given context by dynamically loading a script if needed.\n *\n * @param {string} name - The name of the namespace to check.\n * @param {Object} context - The context in which to check for the namespace (usually the global object).\n * @param {string} path - The path to the script that defines the namespace.\n * @param {boolean} defer - Whether to defer loading of the script.\n * @param {boolean} [module=false] - Whether the script should be loaded as a JavaScript module.\n * @param {boolean} [raise=false] - Whether to throw an error if the script fails to load.\n * @returns {Promise<void>} - A promise that resolves when the namespace is available.\n */\nexport async function ensureNamespace(name, context, path, defer, module = false, raise = false) {\n  if (!(name in context)) {\n    try {\n      await addScript(path, defer, module);\n    } catch (error) {\n      if (raise) {\n        throw new Error(`Failed to ensure namespace: ${name} - ${error.message}`);\n      }\n    }\n  }\n}","/**\n * Creates a throttled function that only invokes the provided function at \n * most once per specified time interval.\n *\n * @param {Function} func - The function to throttle.\n * @param {number} limit - The time interval in milliseconds to limit the \n *                         function calls.\n * @returns {Function} A new throttled function.\n *\n * @example\n * const handleScroll = throttle(() => {\n *   console.log('Scroll event triggered');\n * }, 1000);\n *\n * window.addEventListener('scroll', handleScroll);\n */\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n\n  return function(...args) {\n    const context = this;\n\n    if (!lastRan) {\n      func.apply(context, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(function() {\n        if ((Date.now() - lastRan) >= limit) {\n          func.apply(context, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function \n * until after a specified delay period has elapsed since the last time the \n * debounced function was invoked.\n *\n * @param {Function} func - The function to debounce.\n * @param {number} delay - The number of milliseconds to delay.\n * @returns {Function} A new debounced function.\n *\n * @example\n * const handleResize = debounce(() => {\n *   console.log('Resize event triggered');\n * }, 200);\n *\n * window.addEventListener('resize', handleResize);\n */\nfunction debounce(func, delay) {\n  let timeoutId;\n\n  return function(...args) {\n    if (timeoutId) clearTimeout(timeoutId);\n\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexport const performance = {\n  debounce,\n  throttle\n};","window.__TURTLE__={\n  dev:false,\n  version:\"2.0.0\"\n}\n\nexport * from \"./component/base.js\"\nexport * from \"./component/component.js\"\nexport * from \"./render/data.js\"\nexport * from \"./service/service.js\"\nexport * from \"./context/context.js\"\nexport * from \"./app/app.js\"\nexport * from \"./modules/index.js\"\nexport * from \"./features/index.js\"\nexport {TurtleRenderHelper} from \"./render/render.js\"","export * from \"./index.js\"\n\nwindow.__TURTLE__.dev = false"],"names":["emitDevEvent","name","data","window","__TURTLE__","dev","dispatchEvent","CustomEvent","detail","TurtleComponentElement","HTMLElement","constructor","super","this","app","component","attach","parent","contexts","element","connectedCallback","onInit","start","onCreate","startRender","disconnectedCallback","onDestroy","customElements","define","TurtleRenderData","root","document","createDocumentFragment","refs","bindings","events","addBinding","state","configs","push","addRef","Error","getRef","ref","removeRef","TurtleComponentRef","forwardRefs","extractName","startsWith","substring","length","applyDirective","target","value","context","passed","prefix","directives","ename","DirectiveClass","directiveInstance","apply","addEventListener","bind","type","thtml","ttext","processAttribute","node","attribute","Array","from","attributes","setAttribute","process","tree","childNodes","nodeType","Node","TEXT_NODE","appendChild","ELEMENT_NODE","components","nodeName","componentElement","createElement","getAttribute","newElement","tagName","render","template","raw","values","i","key","Math","floor","random","Date","now","toString","TurtleComponent","instance","content","doc","DOMParser","parseFromString","parserError","getElementsByTagName","errorMessage","textContent","console","log","parseHTML","String","TurtleRenderHelper","fragment","raws","TurtleComponentState","reactive","get","set","watchers","requestUpdate","sync","TurtleContext","_bindings","_values","_events","_isLocal","_reactive","bond","on","callback","off","filter","cb","emit","forEach","TurtleContextManagement","isChildAccess","_contexts","use","isLocal","warn","props","states","renderContext","useContext","getContext","createState","setState","getState","html","setupState","setupWatcher","setupForwardRef","onRender","onUpdate","commit","requestRender","initStates","stateName","createComponent","fn","TurtleService","entity","methods","call","TurtleApp","modules","useModule","module","init","TurtleRouteComponent","matched","routes","isArray","path","p","active","router","status","match","Object","keys","currentPath","TurtleRoute","TurtleRouterModule","_app","url","params","query","URLSearchParams","notallow","notfound","pagematches","pageloaded","pagechange","event","idx","splice","patterns","URL","location","origin","pathname","route","routeSplited","split","urlSplited","undefined","matches","u","emitEvent","j","searchParams","Function","protect","triggerError","loader","ctx","renderContent","started","hash","slice","redirect","replace","history","replaceState","TurtleFormModuleValidatorRules","validations","errors","fieldAlias","alias","rule","isNotNull","trim","maxLength","max","minLength","min","containsNumber","test","containsUppercase","containsLowercase","containsSpecialChar","isEmail","isPhoneNumber","isDate","isNaN","parse","isBefore","date","isAfter","isInRange","matchesRegex","regex","isAlpha","isAlphaNumeric","isNumeric","isUrl","isEqualTo","compareValue","isNotEqualTo","endsWith","suffix","isPositiveNumber","Number","isNegativeNumber","isInteger","isFloat","includes","validate","validation","getErrors","TurtleFormModuleValidator","_module","rules","selector","querySelector","validator","field","messages","triggerEvent","validateWhenSubmit","prevent","preventDefault","TurtleFormModule","form","createFormValidator","addScript","src","asyncLoad","script","d","Promise","resolve","reject","async","onload","onerror","ensureNamespace","defer","raise","error","message","performance","debounce","func","delay","timeoutId","args","clearTimeout","setTimeout","throttle","limit","lastFunc","lastRan","version"],"mappings":"AAUO,SAASA,EAAaC,EAAMC,GAC5BC,OAAOC,WAAWC,KAEvBF,OAAOG,cAAc,IAAIC,YAAY,YAAa,CAChDC,OAAQ,CACNP,OACAC,UAGN,CCZO,MAAMO,UAA+BC,YAI1C,WAAAC,GACEC,QACAC,KAAKC,IAAM,KACXD,KAAKE,UAAY,IAClB,CAQD,MAAAC,CAAOF,EAAKG,EAAQF,GAClBF,KAAKC,IAAMA,EACXD,KAAKE,UAAYA,EACjBF,KAAKE,UAAUE,OAASA,EACxBJ,KAAKE,UAAUG,SAASD,OAASA,EACjCJ,KAAKE,UAAUI,QAAUN,KACzBA,KAAKE,UAAUD,IAAMA,EACrBd,ECP8B,qBDOqBe,EACpD,CAMD,iBAAAK,GACEP,KAAKE,UAAUM,SACfR,KAAKE,UAAUO,QACfT,KAAKE,UAAUQ,WACfV,KAAKE,UAAUS,aAChB,CAMD,oBAAAC,GACEZ,KAAKE,UAAUW,WAEhB,EAIHvB,OAAOwB,eAAeC,OAAO,mBAAoBnB,GEnD1C,MAAMoB,EAMX,WAAAlB,CAAYmB,GACVjB,KAAKiB,KAAOA,GAAQC,SAASC,yBAC7BnB,KAAKoB,KAAO,GACZpB,KAAKqB,SAAW,GAChBrB,KAAKsB,OAAS,EACf,CAQD,UAAAC,CAAWC,EAAOC,GACXzB,KAAKqB,SAASG,KACjBxB,KAAKqB,SAASG,GAAS,IAEzBxB,KAAKqB,SAASG,GAAOE,KAAKD,EAC3B,CAUD,MAAAE,CAAOvC,EAAMkB,GACX,GAAIN,KAAKoB,KAAKhC,GACZ,MAAM,IAAIwC,MAAM,6IAGlB5B,KAAKoB,KAAKhC,GAAQkB,CACnB,CASD,MAAAuB,CAAOzC,GACL,MAAM0C,EAAM9B,KAAKoB,KAAKhC,GACtB,IAAK0C,EACH,MAAM,IAAIF,MAAM,qDAAqDxC,KAEvE,OAAO0C,CACR,CAQD,SAAAC,CAAU3C,GACR,IAAKY,KAAKoB,KAAKhC,GACb,MAAM,IAAIwC,MAAM,wEAAwExC,YAEnFY,KAAKoB,KAAKhC,EAClB,ECrEI,MAAM4C,EACX1B,GAMA,WAAAR,CAAYQ,GACV,IAAKA,EACH,MAAM,IAAIsB,MAAM,6DAElB5B,MAAKM,EAAWA,CACjB,CAOD,aAAIJ,GACF,IAAKF,MAAKM,EAASJ,UACjB,MAAM,IAAI0B,MAAM,mFAElB,OAAO5B,MAAKM,EAASJ,UAAU+B,WAChC,ECjBH,SAASC,EAAY9C,EAAMqB,GACzB,OAAIrB,EAAK+C,WAAW1B,GAAerB,EAAKgD,UAAU3B,EAAM4B,QACjD,IACT,CAWA,SAASC,EAAeC,EAAQnD,EAAMoD,EAAOC,GAC3C,IAAIC,GAAS,EACb,IAAK,IAAIC,KAAUC,EAAY,CAC7B,MAAMC,EAAQX,EAAY9C,EAAMuD,GAC1BG,EAAiBF,EAAoB,MAATC,EAAgBF,EAASvD,GAC3D,IAAK0D,EACH,SAEF,MAAMC,EAAoB,IAAID,EAAeP,EAAQM,EAAOL,EAAOC,GAC5B,mBAA5BM,EAAkBC,QAC3BD,EAAkBC,QAClBN,GAAS,GAEX,KACD,CACD,OAAOA,CACT,CAGA,MAAME,EAAa,CACjB,UCzCK,MASL,WAAA9C,CAAYyC,EAAQnD,EAAMoD,EAAOC,GAC/BzC,KAAKuC,OAASA,EACdvC,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKyC,QAAUA,CAChB,CAKD,KAAAO,GACMhD,KAAKyC,QAAQxB,KAAKjB,KAAKwC,QACzBxC,KAAKuC,OAAOU,iBAAiBjD,KAAKZ,KAAMY,KAAKyC,QAAQxB,KAAKjB,KAAKwC,OAAOU,KAAKlD,KAAKyC,QAAQxB,MAE3F,GDmBD,SCbK,MASL,WAAAnB,CAAYyC,EAAQnD,EAAMoD,EAAOC,GAC/BzC,KAAKuC,OAASA,EACdvC,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKyC,QAAUA,CAChB,CAKD,KAAAO,GACEhD,KAAKyC,QAAQlB,WAAWvB,KAAKwC,MAAO,CAClCW,KAAM,YACN/D,KAAMY,KAAKZ,KACXoC,MAAOxB,KAAKwC,MACZD,OAAQvC,KAAKuC,QAEhB,GDZDa,MCkBK,MASL,WAAAtD,CAAYyC,EAAQnD,EAAMoD,EAAOC,GAC/BzC,KAAKuC,OAASA,EACdvC,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKyC,QAAUA,CAChB,CAKD,KAAAO,GACEhD,KAAKyC,QAAQlB,WAAWvB,KAAKwC,MAAO,CAClCW,KAAM,WACN/D,KAAM,YACNoC,MAAOxB,KAAKwC,MACZD,OAAQvC,KAAKuC,QAEhB,GD3CDc,MCiDK,MASL,WAAAvD,CAAYyC,EAAQnD,EAAMoD,EAAOC,GAC/BzC,KAAKuC,OAASA,EACdvC,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKyC,QAAUA,CAChB,CAKD,KAAAO,GACEhD,KAAKyC,QAAQlB,WAAWvB,KAAKwC,MAAO,CAClCW,KAAM,WACN/D,KAAM,cACNoC,MAAOxB,KAAKwC,MACZD,OAAQvC,KAAKuC,QAEhB,GD1EDT,ICgFK,MASL,WAAAhC,CAAYyC,EAAQnD,EAAMoD,EAAOC,GAC/BzC,KAAKuC,OAASA,EACdvC,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKyC,QAAUA,CAChB,CAKD,KAAAO,GACEhD,KAAKyC,QAAQd,OAAO3B,KAAKwC,MAAOxC,KAAKuC,OACtC,ID1FI,SAASe,EAAiBf,EAAQgB,EAAMd,EAASpD,GACtD,IAAK,IAAImE,KAAaC,MAAMC,KAAKH,EAAKI,YAAa,CACjD,IAAIvE,EAAOoE,EAAUpE,KACjBoD,EAAQgB,EAAUhB,MACJF,EAAeC,EAAQnD,EAAMoD,EAAOC,IAEpDF,EAAOqB,aAAaxE,EAAMoD,EAE7B,CACH,CAWO,SAASqB,EAAQvD,EAASwD,EAAMrB,EAASpD,EAAMY,GACpD,IAAK,IAAIsD,KAAQE,MAAMC,KAAKI,EAAKC,YAC/B,GAAIR,EAAKS,WAAaC,KAAKC,UACzB5D,EAAQ6D,YAAYZ,QACf,GAAIA,EAAKS,WAAaC,KAAKG,aAChC,GAAI/E,EAAKgF,WAAWd,EAAKe,UAAW,CAClC,IAAIpE,EAAYb,EAAKgF,WAAWd,EAAKe,UACjCC,EAAmBrD,SAASsD,cAAc,oBAC9CD,EAAiBpE,OAAOF,EAAKwC,EAAQxB,KAAMf,GACvCqD,EAAKkB,aAAa,QACpBhC,EAAQd,OACN4B,EAAKkB,aAAa,OAClB,IAAIzC,EAAmBuC,IAG3BjE,EAAQ6D,YAAYI,EAC5B,KAAa,CACL,IAAIG,EAAaxD,SAASsD,cAAcjB,EAAKoB,SAC7CrB,EAAiBoB,EAAYnB,EAAMd,GAC/Bc,EAAKQ,WAAW1B,OAAS,GAAGwB,EAAQa,EAAYnB,EAAMd,EAASpD,GACnEiB,EAAQ6D,YAAYO,EACrB,CAGP,CEzFO,SAASE,EAAOtE,EAASuE,EAAUpC,EAAU,IAAIzB,EAAoBf,EAAM,MAChF,IAAI6E,EAAMD,EAASC,IACfC,EAASF,EAASE,OAClB1F,EAAO,CACTgF,WAAY,CAAE,GAGhB,IAAK,IAAIW,EAAI,EAAGA,EAAID,EAAO1C,OAAQ2C,IAAK,CACtC,IAAIC,EAAM,qBAAqBC,KAAKC,MAAsB,OAAhBD,KAAKE,UAAqBC,KAAKC,OAAOC,SAAS,MACrFR,EAAOC,KACLD,EAAOC,aAAcQ,GACvBnG,EAAKgF,WAAWY,GAAOF,EAAOC,GAC9BD,EAAOC,GAAKC,GACHF,EAAOC,GAAGS,WAAaD,IAChCnG,EAAKgF,WAAWY,GAAOF,EAAOC,GAAG,CAAA,GACjCD,EAAOC,GAAKC,GAGjB,CAED,IACInB,EC5BC,SAAmB4B,GACxB,IACIC,GADS,IAAIC,WACAC,gBAAgB,SAASH,WAAkB,YACxDI,EAAcH,EAAII,qBAAqB,eAE3C,GAAID,EAAYzD,OAAS,EAAG,CAC1B,MAAM2D,EAAe,oBAAsBF,EAAY,GAAGG,YAE1D,MADAC,QAAQC,IAAIH,GACN,IAAIpE,MAAMoE,EACpB,CACI,OAAOL,EAAII,qBAAqB,QAAQ,EAE5C,CDgBaK,CADGC,OAAOvB,IAAIA,KAAQC,IAKjC,OAFAlB,EAAQvD,EAASwD,EAAMrB,EAASpD,EAAMY,GAE/BK,CACT,CAEO,MAAMgG,EACX,WAAAxG,CAAYG,EAAIgB,EAAKwB,EAAQ,IAAIzB,GAC/BhB,KAAKC,IAAMA,EACXD,KAAKyC,QAAUA,EACfzC,KAAKiB,KAAOA,CACb,CAED,QAAAsF,CAASzB,KAAOC,GACd,OAAOH,EAAO1D,SAASC,yBAA0B,CAAE2D,MAAKC,UAAU/E,KAAKyC,QAASzC,KAAKC,IACtF,CAED,MAAA2E,CAAO4B,KAAQzB,GACb/E,KAAKiB,KAAKgF,YAAc,GACxBjG,KAAKiB,KAAKkD,YAAYS,EAAO1D,SAASC,yBAA0B,CAAE2D,QAAKC,UAAU/E,KAAKyC,QAASzC,KAAKC,KACrG,EEpDI,MAAMwG,EASX,WAAA3G,CAAYV,EAAMoD,EAAOtC,GACvBF,KAAKZ,KAAOA,EACZY,KAAKwC,MAAQA,EACbxC,KAAKE,UAAYA,EACjBF,KAAK0G,UAAW,CACjB,CAOD,GAAAC,GACE,OAAO3G,KAAKwC,KACb,CAQD,GAAAoE,CAAIpE,GAcF,OAbAxC,KAAKwC,MAAQA,EAETxC,KAAKE,UAAU2G,SAAS7G,KAAKZ,OAC/BY,KAAKE,UAAU2G,SAAS7G,KAAKZ,MAAMoD,GAGjCxC,KAAKE,UAAUwG,UAAY1G,KAAK0G,UAClC1G,KAAKE,UAAU4G,cAAc,CAC3BtF,MAAOxB,KAAKZ,KACZoD,MAAOA,IAIJA,CACR,CASD,IAAAuE,CAAKtE,EAASwC,GAEZ,OADAxC,EAAQsE,KAAK9B,EAAKjF,MACXA,IACR,EC3DI,MAAMgH,EACX,WAAAlH,GACEE,KAAKiH,UAAY,GACjBjH,KAAKkH,QAAU,GACflH,KAAKmH,QAAU,GACfnH,KAAKoH,UAAW,CACjB,CASD,SAAAC,CAAUjI,EAAMoD,GACTxC,KAAKiH,UAAU7H,KAAOY,KAAKiH,UAAU7H,GAAQ,IAClD,IAAK,MAAMkI,KAAQtH,KAAKiH,UAAU7H,GAChCkI,EAAKV,IAAIpE,EAEZ,CAQD,GAAAoE,CAAIxH,EAAMoD,GACRxC,KAAKkH,QAAQ9H,GAAQoD,EACrBxC,KAAKqH,UAAUjI,EAAMoD,EACtB,CAQD,GAAAmE,CAAIvH,GACF,OAAOY,KAAKkH,QAAQ9H,EACrB,CAQD,IAAA2H,CAAK3H,EAAMoC,GACJxB,KAAKiH,UAAU7H,KAAOY,KAAKiH,UAAU7H,GAAQ,IAClDY,KAAKiH,UAAU7H,GAAMsC,KAAKF,EAC3B,CAOD,EAAA+F,CAAGnI,EAAMoI,GACFxH,KAAKmH,QAAQ/H,KAChBY,KAAKmH,QAAQ/H,GAAQ,IAEvBY,KAAKmH,QAAQ/H,GAAMsC,KAAK8F,EACzB,CAOD,GAAAC,CAAIrI,EAAMoI,GACJxH,KAAKmH,QAAQ/H,KACfY,KAAKmH,QAAQ/H,GAAQY,KAAKsB,OAAOlC,GAAMsI,QAAOC,GAAMA,IAAOH,IAE9D,CAOD,IAAAI,CAAKxI,EAAMC,GACLW,KAAKmH,QAAQ/H,IACfY,KAAKmH,QAAQ/H,GAAMyI,SAAQL,GAAYA,EAASnI,IAEnD,EAMI,MAAMyI,EACX,WAAAhI,CAAYM,EAAQmC,GAClBvC,KAAKI,OAASA,EACdJ,KAAKuC,OAASA,CACf,CASD,GAAAoE,CAAIvH,EAAM2I,GAAgB,GACxB,OAAI/H,KAAKuC,OAAOyF,UAAU5I,IAAU2I,GAAiB/H,KAAKuC,OAAOyF,UAAU5I,GAAMgI,SACxE,KAGLpH,KAAKuC,OAAOyF,UAAU5I,GACjBY,KAAKuC,OAAOyF,UAAU5I,GACpBY,KAAKI,OACPJ,KAAKI,OAAOC,SAASsG,IAAIvH,GAAM,QADjC,CAGR,CASD,GAAA6I,CAAI7I,EAAMqD,EAASyF,GAAU,IACvBlI,KAAKuC,OAAOyF,UAAU5I,IAAUY,KAAKI,QAAUJ,KAAKI,OAAOC,SAASsG,IAAIvH,KAC1E8G,QAAQiC,KAAK,sCAAsC/I,gEAErDY,KAAKuC,OAAOyF,UAAU5I,GAAQqD,EAC9BzC,KAAKuC,OAAOyF,UAAU5I,GAAMgI,SAAWc,CACxC,EC1HI,MAAM1C,EAKX,WAAA1F,CAAYsI,GACVpI,KAAKI,OAAS,KACdJ,KAAKC,IAAM,KACXD,KAAKM,QAAU,KACfN,KAAKoI,MAAQA,EACbpI,KAAK6G,SAAW,GAChB7G,KAAKiC,YAAc,GACnBjC,KAAKqI,OAAS,GACdrI,KAAK0G,UAAW,EAChB1G,KAAKgI,UAAY,GACjBhI,KAAKK,SAAW,IAAIyH,EAAwB9H,KAAKI,OAAQJ,MACzDA,KAAKsI,cAAgB,IAAItH,EAAiBhB,MAC1Cb,ETV0B,iBSUqBa,KAChD,CAQD,UAAAuI,CAAWnJ,EAAMqD,EAAQyF,GAAQ,GAC/B,KAAMzF,aAAmBuE,GACvB,MAAM,IAAIpF,MAAM,oEAGlB,OADA5B,KAAKK,SAAS4H,IAAI7I,EAAMqD,EAAQyF,GACzBzF,CACR,CAOD,UAAA+F,CAAWpJ,GACT,OAAOY,KAAKK,SAASsG,IAAIvH,EAC1B,CAMD,QAAIgC,GACF,OAAOpB,KAAKsI,cAAclH,IAC3B,CAQD,WAAAqH,CAAYrJ,EAAMoD,GAChB,IAAIhB,EAAQ,IAAIiF,EAAqBrH,EAAMoD,EAAOxC,MAElD,OADAA,KAAKqI,OAAOjJ,GAAQoC,EACbA,CACR,CAOD,QAAAkH,CAAStJ,EAAMoD,GACRxC,KAAKqI,OAAOjJ,KACfY,KAAKqI,OAAOjJ,GAAQ,IAAIqH,EAAqBrH,EAAMoD,EAAOxC,OAE5DA,KAAKqI,OAAOjJ,GAAMwH,IAAIpE,EACvB,CAOD,QAAAmG,CAASvJ,GACP,OAAOY,KAAKqI,OAAOjJ,GAAMuH,KAC1B,CAOD,KAAAnF,CAAMpC,GACJ,OAAOY,KAAKqI,OAAOjJ,EACpB,CAQD,IAAAwJ,CAAK9D,KAAQC,GAEX,OADeH,EAAO1D,SAASC,yBAA0B,CAAE2D,MAAKC,UAAU/E,KAAKsI,cAAetI,KAAKC,IAEpG,CAOD,UAAA4I,GACE,MAAO,EACR,CAOD,YAAAC,GACE,MAAO,EACR,CAOD,eAAAC,GACE,MAAO,EACR,CAMD,MAAAvI,GAAW,CAMX,QAAAE,GAAa,CAMb,SAAAG,GAAc,CAMd,QAAAmI,GAAa,CAOb,QAAAC,CAASC,GAAU,CAOnB,QAAArE,GAAa,CAOb,mBAAMiC,CAAcoC,GAClBlJ,KAAKqH,UAAU6B,GACf/J,ET1J6B,oBS0JqBa,MAClDA,KAAKiJ,SAASC,EACf,CAMD,mBAAMC,GACJ,IAAI5C,EAAWvG,KAAK6E,WACpB7E,KAAKM,QAAQ2F,YAAc,GAC3BjG,KAAKM,QAAQ6D,YAAYoC,GACzBpH,ETjK8B,qBSiKqBa,MACnDA,KAAKgJ,UACN,CAMD,SAAA3B,CAAU6B,GACR,IAAI7H,EAAWrB,KAAKsI,cAAcjH,SAAS6H,EAAO1H,OAClD,GAAKH,EACL,IAAK,IAAI6B,KAAQ7B,EACG,aAAd6B,EAAKC,OAAqBD,EAAKX,OAAOW,EAAK9D,MAAQ8J,EAAO1G,OAC5C,cAAdU,EAAKC,MAAsBD,EAAKX,OAAOqB,aAAaV,EAAK9D,KAAM8J,EAAO1G,MAE7E,CAMD,UAAA4G,CAAWf,GACT,IAAK,IAAIgB,KAAahB,EACpBrI,KAAKqI,OAAOgB,GAAa,IAAI5C,EAAqB4C,EAAWhB,EAAOgB,GAAYrJ,KAEnF,CAKD,KAAAS,GACET,KAAKiC,YAAcjC,KAAK+I,mBAAqB,CAAA,EAC7C/I,KAAK6G,SAAW7G,KAAK8I,gBAAkB,CAAA,EACvC9I,KAAKoJ,WAAWpJ,KAAK6I,cAAgB,CAAE,EAExC,CAED,WAAAlI,GACEX,KAAKmJ,eACN,EAQI,SAASG,EAAgBxJ,GAM9B,SAASyJ,KAAMnB,GACb,IAAIlI,EAAY,IAAIJ,EAAYsI,GAEhC,OADAlI,EAAUkI,MAAQA,EACXlI,CACR,CAGD,OADAqJ,EAAG9D,SAAWD,EACP+D,CACT,CC/PO,MAAMC,EAMX,WAAA1J,CAAY2J,GACVzJ,KAAKyJ,OAASA,EACdzJ,KAAK0J,QAAU,GACf1J,KAAKgI,UAAY,GACjBhI,KAAKK,SAAW,IAAIyH,EAAwB9H,KAAKyJ,OAAQzJ,KAC1D,CASD,UAAAuI,CAAWnJ,EAAMqD,GACf,KAAMA,aAAmBuE,GACvB,MAAM,IAAIpF,MAAM,oEAElB5B,KAAKK,SAASuG,IAAIxH,EAAMqD,EACzB,CAQD,UAAA+F,CAAWpJ,GACT,OAAOY,KAAKK,SAASsG,IAAIvH,EAC1B,CAQD,MAAA2B,CAAO3B,EAAMoI,GACXxH,KAAK0J,QAAQtK,GAAQoI,EAAStE,KAAKlD,KACpC,CAOD,IAAA2J,GACE,OAAO3J,KAAK0J,OACb,EChDI,MAAME,EAKX,WAAA9J,CAAY2B,EAAU,IACpBzB,KAAKiB,KAAO,KACZjB,KAAKyB,QAAUA,EACfzB,KAAKgI,UAAY,GACjBhI,KAAK6J,QAAU,GACf7J,KAAKK,SAAW,IAAIyH,EAAwB,KAAM9H,MAClDb,EXnBoB,WWmBqBa,KAC1C,CAQD,SAAA8J,CAAUC,EAAQtI,GAChB,OAAOsI,EAAOC,KAAKhK,KAAMyB,EAC1B,CAOD,UAAA+G,CAAWpJ,GACT,OAAOY,KAAKK,SAASsG,IAAIvH,EAC1B,CAQD,UAAAmJ,CAAWnJ,EAAMqD,GACf,KAAMA,aAAmBuE,GACvB,MAAM,IAAIpF,MAAM,oEAElB5B,KAAKK,SAAS4H,IAAI7I,EAAMqD,EACzB,CAOD,MAAAtC,CAAOG,GAEL,GADAnB,EXvDwB,eWuDqBa,QACzCM,aAAmBT,aAGrB,MAAM,IAAI+B,MAAM,oEAFhB5B,KAAKiB,KAAOX,CAIf,CAQD,MAAAsE,CAAOE,KAAQC,GACb,IAAK/E,KAAKiB,KACR,MAAM,IAAIW,MAAM,sGAGlB5B,KAAKiB,KAAKgF,YAAc,GACxBjG,KAAKiB,KAAKkD,YAAYS,EAAO1D,SAASC,yBAA0B,CAAE2D,MAAKC,UAAU,IAAI/D,EAAiBhB,MAAOA,MAC9G,CAED,QAAAuG,CAASzB,KAAOC,GACd,OAAOH,EAAO1D,SAASC,yBAA0B,CAAE2D,MAAKC,UAAU,IAAI/D,EAAiBhB,MAAOA,KAC/F,ECtFI,MAAMiK,UAA6BzE,EACxC,WAAA1F,CAAYsI,GACVrI,MAAMqI,GACNpI,KAAKkK,SAAU,CAChB,CAED,MAAA1J,GACE,MAAO2J,GAAUnK,KAAKoI,MAElB3E,MAAM2G,QAAQD,IAChBnK,KAAKmK,OAAS,GACdA,EAAOtC,SAAQ,EAAG3H,YAAWmK,WACvB5G,MAAM2G,QAAQC,GAChBA,EAAKxC,SAAQyC,GAAKtK,KAAKmK,OAAOG,GAAKpK,IAEnCF,KAAKmK,OAAOE,GAAQnK,CACrB,KAEwB,iBAAXiK,IAChBnK,KAAKmK,OAASA,EAGjB,CAED,MAAAI,GACE,GAAIvK,KAAKC,IAAIuK,OAAQ,CACnB,IAAIA,EAASxK,KAAKC,IAAIuK,QACjBC,EAAQP,GAAWM,EAAOE,MAAMC,OAAOC,KAAK5K,KAAKmK,QAASK,EAAOK,eAClE,IAAa7K,KAAKkK,UACpBlK,KAAKkK,SAAU,EACflK,KAAKM,QAAQ6D,YAAYnE,KAAK4I,IAAI;aAC7B5I,KAAKmK,OAAOD;YAGdO,IACHzK,KAAKkK,SAAU,EACflK,KAAKM,QAAQ2F,YAAc,GAE9B,CACF,CAED,QAAA+C,GACEhJ,KAAKuK,SACDvK,KAAKC,IAAIuK,QACXxK,KAAKC,IAAIuK,OAAOjD,GAAG,aAAcvH,KAAKuK,OAAOrH,KAAKlD,MAErD,CAED,QAAA6E,GACE,OAAO7E,KAAK4I,IAAI,EACjB,EAIS,MAACkC,EAAcxB,EAAgBW,GCjDpC,MAAMc,EAQX,WAAAjL,CAAYG,EAAKwB,GACfzB,KAAKiB,KAAOQ,EAAQnB,SAAWY,SAASsD,cAAc,OACtDxE,KAAKgL,KAAO/K,EACZD,KAAKgL,KAAKnB,QAAQnI,KAAK1B,MACvBA,KAAKgL,KAAKR,OAASxK,KACnBA,KAAKmK,OAAS,GACdnK,KAAKkK,QAAU,KACflK,KAAKiL,IAAM,KACXjL,KAAKkL,OAAS,GACdlL,KAAKmL,MAAQ,IAAIC,gBACjBpL,KAAKsB,OAAS,CACZ+J,SAAU,GACVC,SAAU,GACVC,YAAa,GACbC,WAAY,GACZC,WAAY,GAEf,CAQD,EAAAlE,CAAGmE,EAAOlE,GACRxH,KAAKsB,OAAOoK,GAAOhK,KAAK8F,EACzB,CAQD,GAAAC,CAAIiE,EAAOlE,GACTxH,KAAKsB,OAAOoK,GAAO7D,SAAQ,CAAC0B,EAAIoC,KAC1BpC,IAAO/B,GACTxH,KAAKsB,OAAOoK,GAAOE,OAAOD,EAAK,EAChC,GAEJ,CASD,WAAO3B,CAAK/J,EAAKwB,GACf,OAAO,IAAIsJ,EAAmB9K,EAAKwB,EACpC,CAED,KAAAiJ,CAAMmB,EAAUZ,GAId,GAFAA,EADQ,IAAIa,IAAIb,EAAK3L,OAAOyM,SAASC,QAC7BC,SAEHJ,EAAL,CACA,IAAK,IAAI7G,EAAI,EAAGA,EAAI6G,EAASxJ,OAAQ2C,IAAK,CACxC,IAAIkH,EAAQL,EAAS7G,GACjBmH,EAAeD,EAAME,MAAM,KAC3BC,EAAapB,EAAImB,MAAM,KACvB1J,GAAS,EAGb,GAAI2J,EAAWhK,QAAU8J,EAAa9J,OACpCK,GAAS,OAET,IAAK,IAAIsC,EAAI,EAAGA,EAAImH,EAAa9J,cACTiK,IAAlBD,EAAWrH,KACbtC,GAAS,GAGY,KAAnByJ,EAAanH,IALsBA,IASb,KAAtBmH,EAAanH,GAAG,GAMhBmH,EAAanH,IAAMqH,EAAWrH,KAChCtC,GAAS,IANEyJ,EAAanH,GAAG5C,UAAU,EAAG+J,EAAanH,GAAG3C,QACzCgK,EAAWrH,IAShC,GAAItC,EAAQ,MAAO,EAAC,EAAKwJ,EAC1B,CACD,MAAO,EAAC,EAAM,KAjCC,CAkChB,CAQD,aAAMK,CAAQtB,GACZ,IAAIuB,EAAI,IAAIV,IAAIb,EAAK3L,OAAOyM,SAASC,QACrCf,EAAMuB,EAAEP,SACRjM,KAAKyM,UAAU,aAAczM,MAC7B,IAAK,IAAI0M,EAAI,EAAGA,EAAI/B,OAAOC,KAAK5K,KAAKmK,QAAQ9H,OAAQqK,IAAK,CACxD,IAAIR,EAAQvB,OAAOC,KAAK5K,KAAKmK,QAAQuC,GACjCjL,EAAUzB,KAAKmK,OAAO+B,GACtBC,EAAeD,EAAME,MAAM,KAC3BC,EAAapB,EAAImB,MAAM,KACvB1J,GAAS,EACTwI,EAAS,CAAA,EAEb,GAAImB,EAAWhK,QAAU8J,EAAa9J,OACpCK,GAAS,OAET,IAAK,IAAIsC,EAAI,EAAGA,EAAImH,EAAa9J,cACTiK,IAAlBD,EAAWrH,KACbtC,GAAS,GAGY,KAAnByJ,EAAanH,IALsBA,IASvC,GAA0B,KAAtBmH,EAAanH,GAAG,GAMhBmH,EAAanH,IAAMqH,EAAWrH,KAChCtC,GAAS,OAPX,CAEEwI,EADWiB,EAAanH,GAAG5C,UAAU,EAAG+J,EAAanH,GAAG3C,SACzCgK,EAAWrH,EAE3B,CAQL,GAAItC,EAAQ,CACV1C,KAAKkL,OAASA,EACdlL,KAAKmL,MAAQqB,EAAEG,aACf3M,KAAKkK,QAAUgC,EACflM,KAAKiL,IAAMA,EACX,IAAI/K,EAAY,IAAI0M,SAEpB,GADInL,EAAQ+F,gBAAkB/F,EAAQ+F,WAClC/F,EAAQoL,QAAS,CAEnB,UADmBpL,EAAQoL,UAGzB,YADA7M,KAAK8M,aAAa,YAGrB,CACD9M,KAAKyM,UAAU,cAAezM,MAE1ByB,EAAQsL,SACV7M,QAAkBuB,EAAQsL,UAGxBtL,EAAQvB,YACVA,EAAYuB,EAAQvB,WAEtB,IAAI8M,EAAMhN,KACNM,EAAUN,KAAKiB,KAEnB,SAASgM,EAAcnI,KAAQC,GAC7BzE,EAAQ2F,YAAc,GACtB3F,EAAQ6D,YAAYS,EAAO1D,SAASC,yBAA0B,CAAE2D,MAAKC,UAAU,IAAI/D,EAAiBgM,EAAIhC,MAAOgC,EAAIhC,MACpH,CAGD,OADAhL,KAAKyM,UAAU,aAAczM,MACtBiN,CAAa,IAAI/M,KACzB,CACF,CAEDF,KAAK8M,aAAa,YACnB,CAKD,KAAArM,GACE,IAAIyM,GAAU,EACV7C,EAAO/K,OAAOyM,SAASoB,KACR,GAAf9C,EAAKhI,QACPgI,EAAO,IACP/K,OAAOyM,SAAW,KAElB1B,EAAOA,EAAK+C,MAAM,GAGpB9N,OAAO2D,iBAAiB,aAAc,WACpC,GAAIiK,EAAS,CACX,IAAI7C,EAAO/K,OAAOyM,SAASoB,KAEzB9C,EADiB,GAAfA,EAAKhI,OACA,IAEAgI,EAAK+C,MAAM,GAGpBpN,KAAKuM,QAAQlC,EACd,CACP,EAAMnH,KAAKlD,OACPkN,GAAU,EACVlN,KAAKuM,QAAQlC,GACb6C,GAAU,CACX,CAED,WAAArC,GACE,IAAIR,EAAO/K,OAAOyM,SAASoB,KAM3B,OAJE9C,EADiB,GAAfA,EAAKhI,OACA,IAEAgI,EAAK+C,MAAM,GAEb/C,CACR,CAQD,QAAAgD,CAAShD,EAAMiD,GAAU,GAClBA,GAGHhO,OAAOiO,QAAQC,aAAa,KAAM,KAAM,OAAOnD,KAC/CrK,KAAKuM,QAAQlC,IAHb/K,OAAOyM,SAASoB,KAAO,IAAI9C,GAK9B,CAQD,SAAAoC,CAAUrN,EAAMC,GACdW,KAAKsB,OAAOlC,GAAMyI,SAAQ0B,IACxBA,EAAGlK,EAAK,GAEX,CAOD,YAAAyN,CAAa1N,GACX,OAAQA,GACN,IAAK,YACHY,KAAKyM,UAAU,WAAYzM,MAC3B,MAEF,IAAK,YACHA,KAAKyM,UAAU,WAAYzM,MAGhC,EChRI,MAAMyN,EAIX,WAAA3N,GACEE,KAAK0N,YAAc,GACnB1N,KAAK2N,OAAS,GACd3N,KAAK4N,WAAa,IACnB,CAOD,KAAAC,CAAMzO,GAKJ,OAJAY,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,IAAU,IAEnBxC,KAAK4N,WAAaxO,EACXY,IACR,CAMD,SAAA+N,GAKE,OAJA/N,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,SAA0D,KAAjBA,EAAMwL,OAChEhI,aAAc,mCAEThG,IACR,CAOD,SAAAiO,CAAUC,GAKR,OAJAlO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,EAAMH,QAAU6L,EACjClI,aAAc,yBAAyBkI,uBAElClO,IACR,CAOD,SAAAmO,CAAUC,GAKR,OAJApO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,EAAMH,QAAU+L,EACjCpI,aAAc,0BAA0BoI,uBAEnCpO,IACR,CAMD,cAAAqO,GAKE,OAJArO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,KAAK8L,KAAK9L,GAC3BwD,aAAc,4CAEThG,IACR,CAMD,iBAAAuO,GAKE,OAJAvO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,QAAQ8L,KAAK9L,GAC9BwD,aAAc,sDAEThG,IACR,CAMD,iBAAAwO,GAKE,OAJAxO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,QAAQ8L,KAAK9L,GAC9BwD,aAAc,sDAEThG,IACR,CAMD,mBAAAyO,GAKE,OAJAzO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,yBAAyB8L,KAAK9L,GAC/CwD,aAAc,uDAEThG,IACR,CAMD,OAAA0O,GAKE,OAJA1O,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,6BAA6B8L,KAAK9L,GACnDwD,aAAc,yCAEThG,IACR,CAMD,aAAA2O,GAKE,OAJA3O,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,qBAAqB8L,KAAK9L,GAC3CwD,aAAc,gEAEThG,IACR,CAMD,MAAA4O,GAKE,OAJA5O,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,IAAWqM,MAAMxJ,KAAKyJ,MAAMtM,IACnCwD,aAAc,gCAEThG,IACR,CAOD,QAAA+O,CAASC,GAKP,OAJAhP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,IAAI6C,KAAK7C,GAAS,IAAI6C,KAAK2J,GAC5ChJ,aAAc,uBAAuBgJ,OAEhChP,IACR,CAOD,OAAAiP,CAAQD,GAKN,OAJAhP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,IAAI6C,KAAK7C,GAAS,IAAI6C,KAAK2J,GAC5ChJ,aAAc,sBAAsBgJ,OAE/BhP,IACR,CAQD,SAAAkP,CAAUd,EAAKF,GAKb,OAJAlO,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,GAAS4L,GAAO5L,GAAS0L,EAC1ClI,aAAc,yBAAyBoI,SAAWF,OAE7ClO,IACR,CAOD,YAAAmP,CAAaC,GAKX,OAJApP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU4M,EAAMd,KAAK9L,GAC5BwD,aAAc,2CAEThG,IACR,CAMD,OAAAqP,GAKE,OAJArP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,cAAc8L,KAAK9L,GACpCwD,aAAc,mDAEThG,IACR,CAMD,cAAAsP,GAKE,OAJAtP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,iBAAiB8L,KAAK9L,GACvCwD,aAAc,qDAEThG,IACR,CAMD,SAAAuP,GAKE,OAJAvP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,WAAW8L,KAAK9L,GACjCwD,aAAc,gDAEThG,IACR,CAMD,KAAAwP,GAKE,OAJAxP,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAU,uCAAuC8L,KAAK9L,GAC7DwD,aAAc,+BAEThG,IACR,CAOD,SAAAyP,CAAUC,GAKR,OAJA1P,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,IAAUkN,EAC3B1J,aAAc,0BAA0B0J,OAEnC1P,IACR,CAOD,YAAA2P,CAAaD,GAKX,OAJA1P,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,IAAUkN,EAC3B1J,aAAc,8BAA8B0J,OAEvC1P,IACR,CAOD,UAAAmC,CAAWQ,GAKT,OAJA3C,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,EAAML,WAAWQ,GAClCqD,aAAc,0BAA0BrD,QAEnC3C,IACR,CAOD,QAAA4P,CAASC,GAKP,OAJA7P,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUA,EAAMoN,SAASC,GAChC7J,aAAc,wBAAwB6J,QAEjC7P,IACR,CAMD,gBAAA8P,GAKE,OAJA9P,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,IAAWqM,MAAMrM,IAAUuN,OAAOvN,GAAS,EAClDwD,aAAc,qCAEThG,IACR,CAMD,gBAAAgQ,GAKE,OAJAhQ,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,IAAWqM,MAAMrM,IAAUuN,OAAOvN,GAAS,EAClDwD,aAAc,qCAEThG,IACR,CAMD,SAAAiQ,GAKE,OAJAjQ,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,GAAUuN,OAAOE,UAAUF,OAAOvN,IACzCwD,aAAc,8BAEThG,IACR,CAMD,OAAAkQ,GAKE,OAJAlQ,KAAK0N,YAAYhM,KAAK,CACpBoM,KAAOtL,IAAWqM,MAAMrM,IAAUA,EAAM+C,WAAW4K,SAAS,KAC5DnK,aAAc,2CAEThG,IACR,CAED,QAAAoQ,CAAS5N,GACPxC,KAAK2N,OAAS,GACd,IAAK,MAAM0C,KAAcrQ,KAAK0N,YACvB2C,EAAWvC,KAAKtL,IACnBxC,KAAK2N,OAAOjM,KAAK2O,EAAWrK,cAGhC,OAA8B,IAAvBhG,KAAK2N,OAAOtL,MACpB,CAED,SAAAiO,GACE,OAAOtQ,KAAK2N,MACb,EAOH,MAAM4C,EAMJ,WAAAzQ,CAAYiK,EAAQzJ,GAClBN,KAAKwQ,QAAUzG,EACf/J,KAAKM,QAAUA,EACfN,KAAKsB,OAAS,GACdtB,KAAKyQ,MAAQ,EACd,CAOD,EAAAlJ,CAAGnI,EAAMoI,GACFxH,KAAKsB,OAAOlC,KACfY,KAAKsB,OAAOlC,GAAQ,IAEtBY,KAAKsB,OAAOlC,GAAMsC,KAAK8F,EACxB,CAOD,GAAAC,CAAIrI,EAAMoI,GACJxH,KAAKsB,OAAOlC,KACdY,KAAKsB,OAAOlC,GAAQY,KAAKsB,OAAOlC,GAAMsI,QAAOC,GAAMA,IAAOH,IAE7D,CAKD,QAAA4I,GACE,MAAMrL,EAAS,CAAA,EACT4I,EAAS,GACf,IAAK,MAAM+C,KAAY1Q,KAAKyQ,MAAO,CACjC,MAAMjO,EAAQxC,KAAKM,QAAQqQ,cAAcD,GAAUlO,MAC7CoO,EAAY5Q,KAAKyQ,MAAMC,GACxBE,EAAUR,SAAS5N,GAGtBuC,EAAO6L,EAAUhD,YAAc8C,GAAYlO,EAF3CmL,EAAOjM,KAAK,CAAEmP,MAAOH,EAAUI,SAAUF,EAAUN,aAItD,CAEG3C,EAAOtL,OAAS,EAClBrC,KAAK+Q,aAAa,QAASpD,GAE3B3N,KAAK+Q,aAAa,UAAWhM,EAEhC,CAOD,YAAAgM,CAAa3R,EAAMC,GACbW,KAAKsB,OAAOlC,IACdY,KAAKsB,OAAOlC,GAAMyI,SAAQL,GAAYA,EAASnI,IAElD,CAMD,kBAAA2R,CAAmBC,GAAU,GAC3BjR,KAAKM,QAAQ2C,iBAAiB,SAAU,SAASyI,GAC3CuF,GAASvF,EAAMwF,iBACnBlR,KAAKoQ,UACX,EAAMlN,KAAKlD,MACR,EAMI,MAAMmR,EAMX,WAAArR,CAAYG,EAAKwB,GACfzB,KAAKgL,KAAO/K,EACZD,KAAKgL,KAAKnB,QAAQnI,KAAK1B,MACvBA,KAAKgL,KAAKoG,KAAOpR,KACjBA,KAAKyB,QAAUA,CAChB,CAQD,WAAOuI,CAAK/J,EAAKwB,GACf,OAAO,IAAI0P,EAAiBlR,EAAKwB,EAClC,CAOD,mBAAA4P,CAAoB/Q,GAClB,OAAO,IAAIiQ,EAA0BvQ,KAAMM,EAC5C,ECvdI,SAASgR,EAAUC,EAAKC,GAAY,EAAOzH,GAAS,EAAO0H,GAChE,IAAIC,EAAIxQ,SACR,OAAO,IAAIyQ,SAAQ,CAACC,EAASC,MAC3BJ,EAASC,EAAElN,cAAc,WAClBrB,KAAO,kBACV4G,IAAQ0H,EAAOtO,KAAO,UAC1BsO,EAAOK,MAAQN,EACfC,EAAOM,OAAS,WACdH,GACN,EACIH,EAAOO,QAAU,WACfH,EAAO,IAAIjQ,MAAM,0BAA0B2P,KACjD,EACIE,EAAOF,IAAMA,EACbG,EAAE3L,qBAAqB,QAAQ,GAAG5B,YAAYsN,EAAO,GAEzD,CAaOK,eAAeG,EAAgB7S,EAAMqD,EAAS4H,EAAM6H,EAAOnI,GAAS,EAAOoI,GAAQ,GACxF,KAAM/S,KAAQqD,GACZ,UACQ6O,EAAUjH,EAAM6H,EAAOnI,EAC9B,CAAC,MAAOqI,GACP,GAAID,EACF,MAAM,IAAIvQ,MAAM,+BAA+BxC,OAAUgT,EAAMC,UAElE,CAEL,CCkBY,MAACC,EAAc,CACzBC,SAbF,SAAkBC,EAAMC,GACtB,IAAIC,EAEJ,OAAO,YAAYC,GACbD,GAAWE,aAAaF,GAE5BA,EAAYG,YAAW,KACrBL,EAAKxP,MAAMhD,KAAM2S,EAAK,GACrBF,EACP,CACA,EAIEK,SApDF,SAAkBN,EAAMO,GACtB,IAAIC,EACAC,EAEJ,OAAO,YAAYN,GACjB,MAAMlQ,EAAUzC,KAEXiT,GAIHL,aAAaI,GACbA,EAAWH,YAAW,WACfxN,KAAKC,MAAQ2N,GAAYF,IAC5BP,EAAKxP,MAAMP,EAASkQ,GACpBM,EAAU5N,KAAKC,MAElB,GAAEyN,GAAS1N,KAAKC,MAAQ2N,MATzBT,EAAKxP,MAAMP,EAASkQ,GACpBM,EAAU5N,KAAKC,MAUrB,CACA,GCpCAhG,OAAOC,WAAW,CAChBC,KAAI,EACJ0T,QAAQ,SCAV5T,OAAOC,WAAWC,KAAM"}